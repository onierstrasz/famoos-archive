<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>FAMOOS/Exchange Model</TITLE>
<META NAME="keywords" CONTENT="Object-oriented, reengineering, reverse engineering, code repository, FAMOOS.">
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">
<DIR>

<H1><A NAME="DocumentTitle"><A NAME="_Toc460240136">FAMIX 2.0</A></A></H1></DIR>

<B><I><P>The FAMOOS Information Exchange Model</P>
</B></I><P>Serge Demeyer, Sander Tichelaar and Patrick Steyaert</P>
<ADDRESS>Version 2.0 -- Last Modified: Wednesday, August 25, 1999</ADDRESS>
<ADDRESS>Available on the WWW at: <A HREF="http://www.iam.unibe.ch/~famoos/FAMIX/">http://www.iam.unibe.ch/~famoos/FAMIX/</A></ADDRESS>
<H2><A NAME="_Toc460240137">Abstract</A></H2>
<ADDRESS><A NAME="Abstract">This document defines the exchange model for usage by tool prototypes within the FAMOOS reengineering project. These tools exchange information concerning object-oriented source code. This information is then transferred via flat ASCII streams using the CDIF standard.</ADDRESS>
<P></A>All comments are welcome: <A HREF="mailto:famoos@iam.unibe.ch">famoos@iam.unibe.ch</A>.</P>
<H2><A NAME="_Toc460240138">1) Introduction</A></H2>
<P>The FAMOOS project (<A HREF="http://www.iam.unibe.ch/~famoos/">http://www.iam.unibe.ch/~famoos/</A>) aims to develop a reengineering method for transforming object-oriented legacy code into frameworks. The reengineering method itself is defined around a life cycle model (see Figure 1).</P>
<OL>

<LI><A NAME="_Ref457190712">Requirements Analysis: identifying the concrete reengineering goals</A></LI>
<LI>Model Capture: documenting and understanding the software system</LI>
<LI>Problem Detection: identifying flexibility and quality problems</LI>
<LI>Problem Resolution: selecting new software architectures to correct the problems</LI>
<LI>Reorganisation: transforming the existing software architecture for a new release</LI>
<LI>Change Propagation: ensuring that all client syste<A NAME="_Ref408981443"><A NAME="_Ref410538773">ms benefit from the new release</LI></OL>

<P><IMG SRC="Image224.gif" WIDTH=595 HEIGHT=179></P>
<B><P><A NAME="_Ref422565572"><A NAME="_Toc460240189">Figure 1</A></A>: FAMOOS reengineering life cycle</A></A></P>
</B><P>To realise that life cycle, three research areas which are likely to furnish solutions have been investigated. To understand the context of this work, check out [WHYFAMIX].</P>
<DL>
<DT>Metrics &amp; Heuristics [DETECTM]</DT>
<DD>Applied in phase (3) to identify problems and phase (4) to measure improvement.</DD>
<DT>Grouping [DOCUM]</DT>
<DD>Applied in phase (2) to form software modules and phase (4) to form target architectures.</DD>
<DT>Reorganisation Operations [REORGOP]</DT>
<DD>Applied in phase (5) to perform the actual program transformations and phase (6) to adapt the target software context.</DD>
</DL>
<P>The FAMOOS partners have built a number of tool prototypes for conducting various experiments within those three research areas. However, the source code available for case studies is written in different implementation languages (C++, Ada and to a lesser extent Java and Smalltalk). To avoid equipping all the tool prototypes with parsing technology for all of the implementation languages, a common information exchange model with language specific extensions is specified (see Figure 2). This model has been named <I>FAMIX</I>, standing for FAMOOS Information Exchange Model.</P>
<P><A NAME="_Ref410188662"><IMG SRC="Image225.gif" WIDTH=392 HEIGHT=199></P>
<B><P><A NAME="_Ref422565587"><A NAME="_Toc460240190">Figure 2</A></A>: Conception of the FAMIX Model</A></P>
</B><H2><A NAME="_Ref410210475"><A NAME="_Toc460240139">2) <A NAME="RequirementsSpecification">Requirements Specification</A></A></A></H2>
<P>Based on our experiences with the tool prototypes built so far, plus given a survey of the literature on reengineering repositories and code base management systems we have specified the following requirements list. The list is split up in two, one part defining requirements concerning the data model, the other part specifying issues concerning the representation.</P>
<EM><P>Data Model</P>
<OL>

<LI>Extensible.</EM> To handle the definition of language plug-ins, the data model must allow extensions with language specific entities and properties. Some tool prototypes may also need to define tool specific properties.</LI>
<EM><LI>Sufficient basis for metrics, heuristics, grouping and reengineering operations.</EM> To avoid a common denominator that would ineffective for our goals, we set the lower limit for the model to everything that is required to experiment with the tool prototypes.</LI>
<EM><LI>Readily distillable from source code.</EM> Since it is not our aim to define a model that covers all aspects of all languages, the upper limit to the information the model will contain, is what can be generated by basic code parsing (i.e. parsing without any interpretation of the obtained information. For instance, determining if  a relation denotes an aggregation or a composition is not considered parsing responsibility).  The generated information should be usable by any tool , thus also by language independent tools.</LI></OL>

<EM><P>Representation</P>
<OL>

<LI>Easy to generate by available parsing technology.</EM> Since we cannot wait for future developments, we must use parsers available today keeping an eye on short-term evolution. Within the FAMOOS project, parsing technology comes mainly from the FAST library part of the Audit platform. However, there are a number of other viable alternatives: like the SNiFF+ symbol table which is accessible via an API; like Ada compilers which provide standard API's for accessing internal data structures; like the tables generated by Audit which can be transformed in what is needed; like the Java inspection facilities part of java.lang.reflect or even the Java byte code itself; like Smalltalk inspection facilities and parsers that are part of every Smalltalk implementation.</LI>
<EM><LI>Simple to process.</EM> As the exchange format will be fed into a wide variety of tool prototypes, the format itself should be quite easy to convert into the internal data structures of those prototypes. On top of that, processing by "standard" file utilities (i.e., grep, sed) and scripting languages (i.e., perl, python) must be easy since they may be necessary to cope with format mismatches.</LI>
<EM><LI>Convenient for querying.</EM> A large portion of reengineering is devoted to the search for information. The representation should be chosen so that it may easily be transformed into an input-stream for querying tools (i.e., spreadsheets and databases).</LI>
<EM><LI>Human readable.</EM> The exchange format will be employed by (buggy) prototypes. To ease debugging, the format itself should be readable by humans. Especially, references between entities should be by name rather than by identifiers bearing no semantics.</LI>
<EM><LI>Allows combination with information from other sources.</EM> Although most of the data model will be extracted from source code, we expect that other origins can provide input as well. Especially CASE tools with design diagrams (e.g., TDE or Rational/Rose) are likely candidates. Thus, the representation should allow merging information from other origins. Note that just like with the "human readable" requirement this implies that references between entities should be by name rather than by identifiers bearing no semantics.</LI>
<EM><LI>Supports industry standards.</EM> Since the tool prototypes must be utilised within an industry context, they must integrate with whatever tools already in use. Ad hoc exchange formats (even when they can be translated with scripts) hinder such integration, and --when available-- the representation should favour an industry standard.</LI></OL>

<H2><A NAME="_Toc460240140">3) CDIF Transfer Format</A></H2>
<P>We have adopted CDIF [CDIF94a] as the basis for the information exchange of information in the FAMOOS exchange model [EVALCDIF]. CDIF is an industrial standard for transferring models created with different tools. The main reasons for adopting CDIF are, that firstly it is an industry standard, and secondly it has a standard plain text encoding which tackles the requirements of convenient querying and human readability. Next to that the CDIF framework supports the extensibility we need to define our model and language plug-ins. More information concerning the CDIF standard can be found at <A HREF="http://www.cdif.org/">http://www.eigroup.org/cdif/index.html</A>.</P>
<P>A possible alternative for CDIF is XMI [XMI98]. However, when we started specifying the FAMIX model, XMI was considered too premature. Still, we consider XMI as a promising way to exchange FAMIX-based information.</P>
<H2><A NAME="_Toc460240141">4) Description of FAMIX</A></H2>
<P>This chapter describes the global structure of the FAMIX model. It introduces the core model (which illustrates the core entities and associations), the abstract part of the model (defining the abstract superclasses that will be extended), the basic data types, naming conventions and the level of extraction.</P>
<H3><A NAME="_Toc460240142">4.1. The Core Model</A></H3>
<P>The core model (shown in Figure 3) specifies the entities and relations that can and should be extracted immediately from source code<A NAME="_Ref420648518">.</P>
<P ALIGN="CENTER"><IMG SRC="Image223.gif" WIDTH=546 HEIGHT=277></P>
<B><P><A NAME="_Ref422565258"><A NAME="_Ref422565270"><A NAME="_Toc460240191">Figure 3</A></A>: The Core Model</A></A></P>
</B><P>The core model consists of the main OO entities, namely <CODE>Class</CODE>, <CODE>Method</CODE>, <CODE>Attribute</CODE> and <CODE>InheritanceDefinition</CODE>. For reengineering, we need the other two, the associations  <CODE>Invocation</CODE> and <CODE>Access</CODE>. An <CODE>Invocation</CODE> represents the definition of a <CODE>Method</CODE> calling another <CODE>Method</CODE> and an <CODE>Access</CODE> represents a <CODE>Method</CODE> accessing an <CODE>Attribute</CODE>. These abstractions are needed for reengineering tasks such as dependency analysis, metrics computation and reengineering operations. Typical questions we need answers for are: &quot;are entities strongly coupled?&quot;, &quot;which methods are never invoked?&quot;, &quot;I change this method. Where do I need to change the invocations on this method?&quot;.</P>
<H3><A NAME="_Toc460240143">4.2. The abstract part of the model</A></H3>
<P>The abstract part of the complete model is shown in Figure 4. <CODE>Object</CODE>, <FONT FACE="Courier New" SIZE=2>Property</FONT>, <CODE>Entity</CODE> and <CODE>Association</CODE> are made available to handle the extensibility requirement (see "2) Requirements Specification" - p.<A HREF="#_Ref410210475">*</A>). For specifying language plug-ins, it is allowed to define language specific Objects, plus it is allowed to add language specific attributes to existing Objects. Tool prototypes are more restricted in extensions to the model: they can define tool specific <CODE>Properties</CODE> for existing Objects. Next to that, they can add attributes to existing Objects, but they cannot extend the repertoire of entities and associations. For a complete description of how to extend the model, see appendix "B. How to extend the model" - p.<A HREF="#Howtoextend">*</A>. The abstract classes <CODE>StructuralEntity</CODE> and <CODE>BehaviouralEntity</CODE> are needed by the associations. </P>
<P><IMG SRC="Image226.gif" WIDTH=570 HEIGHT=281></P>
<B><P><A NAME="_Ref423492991"><A NAME="_Toc460240192">Figure 4</A>:  Basic structure of the complete model</A></P>
</B><P>In the following sections we describe the different entities with their attributes, and how these entities are represented in the CDIF transfer format. Some of the attributes might not appear in the CDIF format. Mandatory attributes always appear. Optional attributes that do not appear, have either a default value or are unknown. </P>
<H3><A NAME="_Toc460240144">4.3. Basic Data Types</A></H3>
<P>Besides the usual primitive data types (String, Integer, Boolean) we have a number of extra data types in our model that are considered "basic". These are <CODE>Name</CODE>, <CODE>Qualifier and Index:</P>

<UL>
<LI>Name</CODE> vs. <CODE>Qualifier</CODE><BR>
A <CODE>Name</CODE> is a string that bears semantics inside the model, while a <CODE>Qualifier</CODE> is a string that gets its semantics from outside the model. A <CODE>String</CODE> does not bear any semantics. For instance, a <CODE>uniqueName</CODE> may be used to refer to another object, hence bears semantics inside the model. However, a <CODE>sourceAnchor</CODE> will store some information that must be interpreted by applications outside the model, hence is a qualifier. Finally, a comment line is a string, since it does not bear any semantics understandable by a computer. In CDIF these types are simply represented by Strings, or TextValues if they are multi-valued (see appendix "A. Clarifications on the CDIF Encoding" - p.<A HREF="#MultivaluedStrings">*</A> for a description of multi-valued strings in CDIF).</LI>
<CODE><LI>Index</CODE><BR>
An Index represents a position in some sequence. Indices always have a base of 1. In CDIF this type is represented by an integer.</LI></UL>

<H3><A NAME="namingConventions"><A NAME="_Toc460240145">4.4. Naming Conventions</A></A></H3>
<P>The naming conventions used in the model transfers is as much as possible compliant with UML [Booc96a]. This means that the following rules apply:</P>

<UL>
<LI>scoping via packages: <BR>
global entities, such as classes, functions, global variables and packages themselves receive a unique name by concatenating with the containing package name using "::" as a separator. They will typically look like "<CODE>package::subpackage::classname</CODE>".</LI>
<LI>naming of variables:<BR>
variables, such as attributes, local variables, etc. receive a unique name by concatenating with the containing entity using a "." as a separator. They will typically look like "<CODE>package::subpackage::classname.attributename</CODE>", "<CODE>package::subpackage::classname.method().localvariablename</CODE>"</LI>
<LI>naming of methods and functions:<BR>
methods and functions distinguish themselves from variables because they have an parameter list. Therefore, they are named by concatenating their scope and their signature. For functions we follow the convention of package scoping, thus separate the scope and the signature via a "::". For methods we follow the convention of variable naming, thus separate the scope and the signature via a ".".<BR>
The signature of a method and a function contains the name of the method or function, followed by its parameter list surrounded by parentheses. The return type is not part of the signature. They will typically look like "<CODE>package::subpackage::functionname(para1,para2)</CODE>",  "<CODE>package::subpackage::classname.methodname(para1,para2)</CODE>"<BR>
To achieve a normal form for signatures, parameter lists should not contain unnecessary spaces. Thus<BR>
"<CODE>functionname(para1,para2)</CODE>"<BR>
instead of<BR>
"<CODE>functionname(para1, para2)</CODE>".<BR>
However, sometimes languages include keywords in their parameter list, and then spaces can not be avoided. For instance, the C++ const parameters will be represented like<BR>
"<CODE>functionname(const para1,const para2)</CODE>" </LI></UL>

<H3><A NAME="_Toc460240146">4.5. Level of Extraction</A></H3>
<P>The core model contains entities that not all parsers may provide. Next to that, some tools do not always need all of this information (e.g. a metrics tool might not need <CODE>Invocation</CODE> and <CODE>Access</CODE>, because many metrics can already be gathered from <CODE>Class</CODE> and <CODE>Method</CODE> alone). To allow focused models, we introduce the <EM>level of extraction</EM>. </P>
<P>Basically, the level of extraction is an integer, telling how much of the core model is actually extracted. In principle, the higher the number, the more information is available. The levels are set up in such a way that no information is available on a level that needs information from higher levels (for instance, <CODE>Access </CODE>is not usable if there are no <CODE>Attribute</CODE>'s available). Next to that, it is possible that on the higher levels parts of the information aren't necessary for a certain task, or simply not computable by a certain tool. Therefore it is allowed to only provide parts of the information (designated by the "+/-").</P>
<P>Table 1 gives an overview of the levels of extraction.</P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=595>
<TR><TD WIDTH="13%" VALIGN="TOP" HEIGHT=80>
<P>Level 1</TD>
<TD WIDTH="87%" VALIGN="TOP" HEIGHT=80>
<CODE><P>Class, InheritanceDefinition, BehaviouralEntity (Method, Function)</CODE> <BR>
              +/- <CODE>Package</P>
</CODE><P>Level 1 is the minimum model that parsers should be able to provide and corresponds with what is usually understood as the interface of a class.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP" HEIGHT=26>
<P>Level 2</TD>
<TD WIDTH="87%" VALIGN="TOP" HEIGHT=26>
<CODE><P>Level 1 +/- Attribute</CODE> <BR>
              +/- <CODE>GlobalVariable</CODE></TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP" HEIGHT=29>
<P>Level 3</TD>
<TD WIDTH="87%" VALIGN="TOP" HEIGHT=29>
<CODE><P>Level 2</CODE>&#9;<CODE>+/- Access</CODE> <BR>
              +/- <CODE>Invocation</CODE></TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP" HEIGHT=43>
<P>Level 4</TD>
<TD WIDTH="87%" VALIGN="TOP" HEIGHT=43>
<CODE><P>Level 3</CODE>&#9;<CODE>+/- Argument</CODE> <BR>
              +/- <CODE>FormalParameter</CODE><BR>
              +/- <CODE>LocalVariable</CODE><BR>
              +/- <CODE>ImplicitVariable</CODE></TD>
</TR>
</TABLE>

<B><P><A NAME="_Ref415979631"><A NAME="_Ref415979649"><A NAME="_Ref420488590"><A NAME="_Toc460240213">Table 1</A>: Levels of </A>Extraction</A></A></P>
</B><H2>&nbsp;</H2>
<H2><A NAME="_Toc460240147">5) Definition of FAMIX</A></H2>
<P>This chapter describes the various classes that together specify the FAMIX model.</P>
<H3><A NAME="_Toc460240148">5.1. The abstract part: Object, Entity and Association</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=548>
<TR><TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="47%" VALIGN="TOP" COLSPAN=3>
<B><I><P ALIGN="CENTER">Object</B></I></TD>
<TD WIDTH="19%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="25%" VALIGN="TOP">
<B><P ALIGN="CENTER">Property</B></TD>
</TR>
<TR><TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="47%" VALIGN="TOP" COLSPAN=3>
<P>sourceAnchor (): Qualifier<BR>
commentsAt (pos Integer): String</TD>
<TD WIDTH="19%" VALIGN="TOP">
<P><IMG SRC="Image214.gif" WIDTH=120 HEIGHT=32></TD>
<TD WIDTH="25%" VALIGN="TOP">
<P>name (): Qualifier<BR>
value (): String</TD>
</TR>
<TR><TD WIDTH="10%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="47%" VALIGN="TOP" COLSPAN=3>
<P ALIGN="CENTER"><IMG SRC="Image179.gif" WIDTH=239 HEIGHT=40></TD>
<TD WIDTH="44%" VALIGN="TOP" COLSPAN=2>&nbsp;</TD>
</TR>
<TR><TD WIDTH="48%" VALIGN="TOP" COLSPAN=2>
<B><I><P ALIGN="CENTER">Association</B></I></TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=3>
<B><I><P ALIGN="CENTER">Entity</B></I></TD>
</TR>
<TR><TD WIDTH="48%" VALIGN="TOP" COLSPAN=2>&nbsp;</TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=3>
<P>name (): Name<BR>
uniqueName (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Ref423852716"><A NAME="_Toc460240193">Figure 5</A>: The basic classes Object, Entity and Association</A></P>
</B><P>As stated in section 4.2, the classes <CODE>Object</CODE>, <CODE>Entity</CODE>, <CODE>Association</CODE> and <CODE>Property</CODE> are added to provide extensibility to the model.</P>
<P>Object is an abstract class without a superclass. Association and Entity are both abstract classes inheriting from Object. Property is a concrete class without a superclass. The attributes of these basic classes are: </P>

<UL>
<CODE><LI>sourceAnchor: Qualifier; optional</CODE><BR>
Identifies the location in the source where the information is extracted.<BR>
The exact format of the qualifier is dependent on the source of the information. Usually, it will be an anchor in a source file, in which case the following format should be used<BR>
&#9;<CODE>file "&lt;filespec&gt;" start &lt;start_index&gt; end &lt;end_index&gt;</CODE>.<BR>
Where &lt;<CODE>filespec</CODE>&gt; is a string holding the name of the source-file in an operating system dependent format (preferably a filename relative to some project directory). Note that filenames may contain spaces and double quotation marks. A double quotation mark in a filename should be escaped with a <FONT FACE="Courier New" SIZE=2>\"</FONT>. &lt;<CODE>start_index</CODE>&gt; and &lt;<CODE>end_index</CODE>&gt; are indices starting at 1 and holding the beginning/ending character position in the source file.<BR>
Extra position indices or whole source anchors may be added to handle anchors in files that may need to be displayed with external editors. For instance, the line and column of the character (<CODE>startline</CODE>, <CODE>startcol</CODE>, <CODE>endline</CODE>, <CODE>endcol</CODE>). Or the negative offset counting from the end of the file instead of from the beginning (<CODE>negstart</CODE>, <CODE>negend</CODE>). In CDIF a basic source anchor looks as follows (delimited with a |, see appendix "A. Clarifications on the CDIF Encoding" - p.<A HREF="#MultivaluedStrings">*</A> for a description of multi-valued strings in CDIF):<BR>
<BR>
<CODE>(sourceAnchor #[file "factory.h" start 260 end 653|]#)</LI>
<LI>comments: 0..N String; optional</CODE><BR>
Entities and associations may own a number of comments, where developers and tools store textual information about the object. In CDIF we represent this with a CDIF TextValue, where the blocks are delimited by a | (see appendix "A. Clarifications on the CDIF Encoding" - p.<A HREF="#MultivaluedStrings">*</A> for a description of multi-valued strings in CDIF):<BR>
<BR>
<CODE>(comments #[commentLines|]#,#[commentLines|]#,...)</LI></UL>

</CODE><P>Entities and associations may own a number of properties where extensions of the core model may be stored. A <CODE>Property</CODE> has the following attributes:</P>

<UL>
<CODE><LI>name: Qualifier; mandatory</CODE><BR>
Is a string that identifies a <CODE>Property</CODE> within an Object. Thus, the name should be unique for all properties of a single Object.</LI>
<CODE><LI>value: String; mandatory</CODE><BR>
Contains the value of the property. The meaning of the value is not defined within this model.</LI></UL>

<P>CDIF example showing a class <CODE>Widget</CODE> with a <CODE>Property</CODE> containing the value 5 for some  number-of-methods metric. They are related by the relationship <CODE>HasProperty</CODE>:</P><DIR>

<PRE>&#9;(Class ENT001<BR>
     &#9;(name "Widget")<BR>
&#9;&#9;....<BR>
&#9;)<BR>
<BR>
&#9;(Property PR005<BR>
&#9;&#9;(name  "metric_NOM")<BR>
&#9;&#9;(value #[5]#)<BR>
&#9;)<BR>
<BR>
&#9;(Entity.HasProperty.Property REL003 ENT001 PR005)</PRE></DIR>

<P>To enable a global referencing scheme based on names, the key classes in the model should respect the minimal interface of <CODE>Entity</CODE>.</P>

<UL>
<CODE><LI>name: Qualifier; mandatory</CODE><BR>
Is a string that provides some human readable reference to an entity.</LI>
<CODE><LI>uniqueName: Name; mandatory</CODE><BR>
Is a string that is computed based on the name of the entity. Each class of entities must define its specific formula. The uniqueName serves as an external reference to that entity and must be unique for all entities in the model.</LI></UL>

<H3><A NAME="_Toc460240149">5.2. Model</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">Model</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>exporterName (): String<BR>
exporterVersion (): String<BR>
exporterDate (): String<BR>
exporterTime (): String<BR>
publisherName (): String<BR>
parsedSystemName (): String<BR>
extractionLevel (): String<BR>
sourceLanguage (): String<BR>
sourceDialect (): String</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc460240194">Figure 6: Model</A></P>
</B><P>A Model represents information concerning the particular system being modelled. Parsers must ensure that there is only instance of a Model in a complete transfer.</P>
<P>Model is a concrete class inheriting from Object. Besides inherited attributes, it has the following attributes: </P>

<UL>
<LI>exporterName: String; mandatory<BR>
Represents the name of the tool that generated the information.</LI>
<LI>exporterVersion: String; mandatory<BR>
Represents the version of the tool that generated the information.</LI>
<LI>exporterDate: String; mandatory<BR>
Represents the date the information was generated.</LI>
<LI>exporterTime: String; mandatory<BR>
Represents the time of the day the information was generated.</LI>
<LI>publisherName: String; mandatory<BR>
Represents the name of the person that generated the information. Provide an empty string if this information is not known.</LI>
<LI>parsedSystemName: String; optional<BR>
Represents the name of the system where the information was extracted from.</LI>
<LI>extractionLevel: String; mandatory<BR>
Represents the level of extraction used when generating the information (see Table 1: Levels of Extraction - p. <A HREF="#_Ref420488590">*</A>).</LI>
<LI>sourceLanguage: String; mandatory<BR>
Identifies the implementation language of the parsed source code. For the implementation languages that are relevant in FAMOOS this should be one of "C++", "Ada", "Java", or "Smalltalk".</LI>
<LI>sourceDialect: String.; optional<BR>
Identifies the dialect of the implementation language of the parsed source code. The exact contents of the string is a language dependent issue, e.g. "Borland", "ANSI", for C++. </LI></UL>

<P>CDIF Example of a model for a WidgetLibrary system implemented in Java</P>
<PRE>(Model FM0<BR>
&#9;(exporterName "sniff2famix")<BR>
&#9;(exporterVersion "2.0")<BR>
&#9;(exporterDate "1999/10/19")<BR>
&#9;(exporterTime "00.00.01")<BR>
&#9;(publisherName "Sander Tichelaar")<BR>
&#9;(parsedSystemName "WidgetLibrary")<BR>
&#9;(extractionLevel "3")<BR>
&#9;(sourceLanguage "Java")<BR>
&#9;(sourceDialect -NULL-)<BR>
)</PRE>
<H3><A NAME="_Toc460240150">5.3. Package</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">Package</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToPackage (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc460240195">Figure 7: Package</A></P>
</B><P>A Package represents a named sub-unit of a source code model, for example namespaces in C++,  and packages in Java. What exactly constitutes such a sub-unit is a language dependent issue. Packages and other entities can only belong to one Package.</P>
<P>Package is a concrete class inheriting from Entity. Besides inherited attributes, it has the following attributes: </P>

<UL>
<CODE><LI>belongsToPackage: name; optional</CODE><BR>
Is the unique name of the package containing this package. A null value represents the fact that there is no containing package.</LI>
<LI>formula for <CODE>uniqueName</CODE> (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>):<BR>
<BR>
<CODE>if isNull (belongsToPackage(package)) then<BR>
&#9;  uniqueName (package) = name (package)<BR>
&#9;else<BR>
&#9;  uniqueName (package) = belongsToPackage (package)<BR>
&#9;    + "::" + name (package)</LI></UL>

</CODE><P>CDIF Example of a package gui</P>
<PRE>(Package FM1<BR>
&#9;(name "gui")<BR>
&#9;(<CODE>belongsToPackage </CODE>-NULL-)<BR>
&#9;(uniqueName "gui")<BR>
)</PRE>
<H3><A NAME="_Toc460240151">5.4. Class</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">Class</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>isAbstract (): Boolean<BR>
belongsToPackage (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Ref410484365"><A NAME="_Toc410624945"><A NAME="_Toc460240196">Figure 8: Class</A></A></A></P>
</B><P>A <CODE>Class</CODE> represents the definition of a class in source code. What exactly constitutes such a definition is a language dependent issue. </P>
<P>Class is a concrete class inheriting from Entity. Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>isAbstract: Boolean; optional</CODE><BR>
Is a predicate telling whether the class is declared abstract. Abstract classes are important in OO modelling, but how they are recognised in source code is a language dependent issue.</LI>
<CODE><LI>belongsToPackage</CODE> <CODE>: Name; optional</CODE><BR>
Is the unique name of the package defining the scope of the class. A null belongsToPackage is allowed, it means that the class has global scope. The belongsToPackage concatenated with the name of the class must provide a unique name for that class within the model.</LI>
<LI>formula for uniqueName (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>):<BR>
<BR>
<CODE>if isNull (belongsToPackage</CODE> <CODE>(class)) then<BR>
&#9;  uniqueName (class) = name (class)<BR>
&#9;else<BR>
&#9;  uniqueName (class) = belongsToPackage</CODE> <CODE>(class)<BR>
&#9;    + "::" + name (class)</LI></UL>

</CODE><P>CDIF Example of a non-abstract class Widget in package gui (note the difference between name and uniqueName)</P>
<PRE>(Class FM1<BR>
&#9;(name "Widget")<BR>
&#9;(uniqueName "gui::Widget")<BR>
&#9;(isAbstract -FALSE-)<BR>
&#9;(sourceAnchor #[file "factory.h" start 260 end 653|]#)<BR>
)</PRE>
<H3><A NAME="_Toc460240152">5.5. BehaviouralEntity Hierarchy</A></H3>
<P><IMG SRC="Image188.gif" WIDTH=356 HEIGHT=176></P>
<B><P><A NAME="_Toc460240197">Figure 9: BehaviouralEntity Hierarchy</A></P>
</B><P>The entities that define behaviour in our model are all subclasses of <CODE>BehaviouralEntity.</P>
</CODE><H3><A NAME="_Toc460240153">5.6. BehaviouralEntity</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><I><P ALIGN="CENTER">BehaviouralEntity</B></I></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>accessControlQualifier (): Qualifier<BR>
signature (): Qualifier<BR>
isPureAccessor (): Boolean<BR>
declaredReturnType (): Qualifier<BR>
declaredReturnClass (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Ref457190772"><A NAME="_Toc460240198">Figure 10: BehaviouralEntity</A></A></P>
</B><P>A <CODE>BehaviouralEntity</CODE> represents the definition in source code of a behavioural abstraction, i.e. an abstraction that denotes an action rather than a part of the state. Subclasses of this class represent different mechanisms for defining such an entity. </P>
<P>BehaviouralEntity is an abstract class inheriting from Entity. Besides inherited attributes, it has the following attributes:<CODE> </P>

<UL>
<LI>accessControlQualifier: Qualifier; optional</CODE><BR>
Is a string with a language dependent interpretation, that defines who is allowed to invoke it (for instance, 'public', 'private').</LI>
<CODE><LI>signature: Qualifier; mandatory</CODE><BR>
Is a string that allows to uniquely distinguish a behavioural entity. This is necessary because there exist OO languages (i.e., C++, Java) that allow to overload methods, so that the same method name may be associated with different parameter lists, each with its own method body. The way a signature string is composed is language dependent, but it should at least include the name of the method. The UML [Booc96a] compliant notation will be used, which will typically look like (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>) "<CODE>package::subpackage::classname.methodname(parameters)</CODE>" .</LI>
<CODE><LI>isPureAccessor: Boolean; optional</CODE><BR>
Is a predicate telling whether the behavioural entity is a pure accessor. There are two kinds of accessors, a reader accessor and a writer accessor. A pure reader accessor  is an entity with a single receiver parameter, only returning the value of an attribute of the class the method is defined on. A pure writer accessor is a method with one receiver parameter and one value parameter, only storing the value inside the attribute of a class. How accessor methods are recognised in source code is a language dependent issue.</LI>
<CODE><LI>declaredReturnType: Qualifier; optional</CODE><BR>
Is a qualifier that via interpretation outside the model refers to the type of the returned object. Typically this will be a class, a pointer or a primitive type (e.g. "<CODE>int</CODE>" in Java). <CODE>declaredReturnType</CODE> is null if the return type is not known or the empty string (i.e. "") if the <CODE>BehavourialEntity</CODE> does not have a return type (for instance, the C++ void; we  don't use "void", because this causes problems for languages where it is possible to define a class called "void", like for instance Smalltalk and Ada). Note that this is consistent with UML 1.1 [Booc96a].<BR>
Note that we need a language dependent interpretation to link a type name to a class name, because in most OO languages, types are not always equivalent to a class. How the declared return type may be recognised in source code and how the return type matches to a class or another type are language dependent issues.</LI></UL>


<UL>
<CODE><LI>declaredReturnClass: Name; optional</CODE><BR>
The unique name of the class that is implicit in the <CODE>declaredReturnType</CODE>. The <CODE>declaredReturnType</CODE> might be the class itself, but might also be a pointer to a class (for instance, Class* in C++) or a primitive type (such as "<CODE>int</CODE>" in Java), or  something else depending on the language. Therefore, the <CODE>declaredReturnClass</CODE> will contain the name of the class which is designated already by the <CODE>declaredReturnType</CODE>, or the name of the class where the <CODE>declaredReturnType</CODE> points to, null if it is unknown if there is an implicit class in the <CODE>declaredRetunType</CODE>, and the empty string (i.e. "") if it is known that there is no implicit class in the <CODE>declaredReturnType</CODE>. What exactly is the relationship between <CODE>declaredReturnClass</CODE> and <CODE>declaredReturnType</CODE> is a language-dependent issue.<BR>
Note that this is useful information for, among others, dependency analysis (a requirement for this model), hence the presence in this model. </LI></UL>

<H3><A NAME="_Toc460240154">5.7. Method</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">Method</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToClass (): Name<BR>
hasClassScope (): Boolean<BR>
isAbstract (): Boolean<BR>
isConstructor (): Boolean</TD>
</TR>
</TABLE>

<B><P><A NAME="_Ref410538730"><A NAME="_Toc410624946"><A NAME="_Toc460240199">Figure 11: Method</A></A></A></P>
</B><P>A <CODE>Method</CODE> represents the definition in source code of an aspect of the behaviour of a class. What exactly constitutes such a definition is a language dependent issue. </P>
<P>Method is a concrete class inheriting from BehaviouralEntity. Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToClass: Name; mandatory</CODE><BR>
Is a name referring to the class owning the method. It uses the uniqueName of the class as a reference.</LI>
<CODE><LI>hasClassScope: Boolean; optional</CODE><BR>
Is a predicate telling whether the method has class scope (i.e., invoked on the class) or instance scope (i.e., invoked on an instance of that class). For example, static methods in C++ and Java have a hasClassScope attribute set to true.</LI>
<CODE><LI>isAbstract: Boolean; optional</CODE><BR>
Is a predicate telling whether the method is declared abstract, i.e. when subclasses are forced to provide an implementation for this method. Abstract methods are important in OO modelling, but how they are recognised in source code is a language dependent issue.</LI>
<CODE><LI>isConstructor: Boolean; optional</CODE><BR>
Is a predicate telling whether the method is a constructor. A constructor is a method that creates an (initialised) instance of the class it is defined on. Thus a method that creates an instance of another class is not considered a constructor. How constructor methods are recognised in source code is a language dependent issue.</LI>
<LI>formula for uniqueName  (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>):</LI></UL>

<PRE>&#9;uniqueName (method) = belongsToClass (method) +<BR>
&#9;  "." + signature (method)</PRE>
<P>CDIF Example (constructor for a class <CODE>Widget. This method has no return type and therefore also no "return class", hence both attributes are empty</CODE>):</P>
<PRE>(Method FM2<BR>
&#9;(name "Widget")<BR>
&#9;(belongsToClass "gui::Widget")<BR>
&#9;(sourceAnchor #[file "factory.h" start 321 end 326|]#)<BR>
&#9;(accessControlQualifier "public")<BR>
&#9;(hasClassScope -FALSE-)<BR>
&#9;(signature "Widget()")<BR>
&#9;(isAbstract -FALSE-)<BR>
&#9;(declaredReturnType "")<BR>
&#9;(declaredReturnClass "")<BR>
&#9;(uniqueName "gui::Widget.Widget()")<BR>
)</PRE>
<H3><A NAME="_Toc460240155">5.8. Function</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">Function</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToPackage (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc460240200">Figure 12: Function</A></P>
</B><P>A <CODE>Function</CODE> represents the definition in source code of an aspect of global behaviour. What exactly constitutes such a definition is a language dependent issue. </P>
<P>Function is a concrete class inheriting from BehaviouralEntity. Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToPackage</CODE> <CODE>: Name; optional</CODE><BR>
Is the unique name of the package defining the scope of the function. A null belongsToPackage is allowed, it means that the function has global scope. The belongsToPackage concatenated with the name of the function must provide a unique name for that class within the model.</LI>
<LI>formula for uniqueName (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>):<BR>
<BR>
<CODE>if isNull (belongsToPackage</CODE> <CODE>(function)) then<BR>
&#9;  uniqueName (function) = name (function)<BR>
&#9;else<BR>
&#9;  uniqueName (function) = belongsToPackage</CODE> <CODE>(function)<BR>
&#9;    + "::" + name (function)</LI></UL>

</CODE><P>CDIF Example (of a global function "testFactory" without arguments and return type in sub package "test" of package "widgetfactory"):</P>
<PRE>(Function FM2<BR>
&#9;(name "testFactory")<BR>
&#9;(sourceAnchor #[file "factory.h" start 321 end 326|]#)&#9;(accessControlQualifier "public")<BR>
&#9;(signature "testFactory()")<BR>
&#9;(<CODE>belongsToPackage</CODE> "widgetfactory::test")<BR>
&#9;(declaredReturnType "")<BR>
&#9;(declaredReturnClass "")<BR>
&#9;(uniqueName "widgetfactory::test::testFactory()")<BR>
)</PRE>
<H3><A NAME="_Toc460240156">5.9. StructuralEntity Hierarchy</A></H3>
<P><A NAME="_Ref420648562"><A NAME="_Ref410622212"><IMG SRC="Image227.gif" WIDTH=526 HEIGHT=286></P>
<B><P><A NAME="_Ref422565297"><A NAME="_Toc460240201">Figure 13</A></A>: StructuralEntity Hierarchy</A></A></P>
</B><P>All possible variable definitions are subclasses of the class <CODE>StructuralEntity</CODE>. <CODE>StructuralEntity</CODE> itself participates in the <CODE>Access</CODE> association.</P>
<H3><A NAME="_Toc460240157">5.10. StructuralEntity</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><I><P ALIGN="CENTER">StructuralEntity</B></I></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>declaredType (): Qualifier<BR>
declaredClass (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624953"><A NAME="_Ref423939736"><A NAME="_Ref423939771"><A NAME="_Toc460240202">Figure 14: </A>StructuralEntity</A></A></A></P>
</B><P>A <CODE>StructuralEntity</CODE> represents the definition in source code of a structural entity, i.e. it denotes an aspect of the state of a system. The different kinds of structural entities mainly differ in lifetime: some have the same lifetime as the entity they belong to, e.g. an attribute and a class, some have a lifetime that is the same as the whole system, e.g. a global variable. Subclasses of this class represent different mechanisms for defining such an entity. </P>
<P>StructuralEntity is an abstract class inheriting from Entity. Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>declaredType: Qualifier; optional</CODE><BR>
Is a qualifier that via interpretation outside the model refers to the type of the defined structure. Typically this will be a class, a pointer or a primitive type (e.g. "<CODE>int</CODE>" in Java). <CODE>declaredType</CODE> is null if the return type is not known or the empty string (i.e. "") if the <CODE>StructuralEntity</CODE> does not have a return type (for instance, the C++ void; we  don't use "void", because this causes problems for languages where it is possible to define a class called "void", like for instance Smalltalk and Ada). Note that this is consistent with UML 1.1 [Booc96a].<BR>
Note that we need a language dependent interpretation to link a type name to a class name, because in most OO languages, types are not always equivalent to a class. How the declaredType may be recognised in source code and how the type matches to a class are language dependent issue.</LI>
<CODE><LI>declaredClass: Name; optional</CODE><BR>
The unique name of the class that is implicit in the <CODE>declaredType</CODE>. The <CODE>declaredType</CODE> might be the class itself, but might also be a pointer to a class (for instance, Class* in C++) or a primitive type (such as "<CODE>int</CODE>" in Java), or  something else depending on the language. Therefore, the <CODE>declaredClass</CODE> will contain the name of the class which is designated already by the <CODE>declaredType</CODE>, or the name of the class where the <CODE>declaredType</CODE> points to, null if it is unknown if there is an implicit class in the declared type, and the empty string (i.e. "") if it is known that there is no implicit class in the <CODE>declaredReturnType</CODE>. What exactly is the relationship between <CODE>declaredClass</CODE> and <CODE>declaredType</CODE> is a language-dependent issue.<BR>
Note that this is useful information for, among others, dependency analysis (a requirement for this model), hence the presence in this model.</LI></UL>

<H3><A NAME="_Toc460240158">5.11. Attribute</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">Attribute</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToClass (): Name<BR>
accessControlQualifier (): Qualifier<BR>
hasClassScope (): Boolean</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624947"><A NAME="_Toc460240203">Figure 15: Attribute</A></A></P>
</B><P>An <CODE>Attribute</CODE> represents the definition in source code of an aspect of the state of a class. What exactly constitutes such a definition is a language dependent issue.</P>
<P>Attribute is a concrete class inheriting from StructuralEntity . Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToClass: Name; mandatory</CODE><BR>
Is a name referring to the class owning the attribute. It uses the uniqueName of the class as a reference.</LI>
<CODE><LI>accessControlQualifier: Qualifier; optional</CODE><BR>
Is a string with a language dependent interpretation, that defines who is allowed to access it (for instance, 'public', 'private').</LI></UL>


<UL>
<CODE><LI>hasClassScope: Boolean; optional</CODE><BR>
Is a predicate telling whether the attribute has class scope (i.e., shared memory location for all instances of the class) or instance scope (i.e., separate memory location for each instance of the class). For example, static attributes in C++ and Java have a hasClassScope attribute set to true.</LI></UL>


<UL>
<LI>formula for uniqueName (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>):</LI></UL>

<PRE>&#9;uniqueName (attribute) = belongsToClass (attribute) +<BR>
&#9;  "." + name (attribute)</PRE>
<P>CDIF Example of a private attribute <CODE>wTop</CODE> in class <CODE>Widget</CODE>:</P>
<PRE>(Attribute FM22<BR>
&#9;(name "wTop")<BR>
&#9;(belongsToClass "gui::Widget")<BR>
&#9;(sourceAnchor #[file "factory.h" start 281 end 284|]#)<BR>
&#9;(declaredType "int")<BR>
&#9;(declaredClass "")<BR>
&#9;(accessControlQualifier "private")<BR>
&#9;(uniqueName "gui::Widget.wTop")<BR>
)</PRE>
<H3><A NAME="_Toc460240159">5.12. GlobalVariable</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">GlobalVariable</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToPackage (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624954"><A NAME="_Toc460240204">Figure 16: GlobalVariable</A></A></P>
</B><P>A <CODE>GlobalVariable</CODE> represents the definition in source code of a variable with a lifetime equal to the lifetime of a running system, and which is globally accessible. What exactly constitutes such a definition is a language dependent issue. </P>
<P>GlobalVariable is a concrete class inheriting from StructuralEntity . Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToPackage</CODE> <CODE>: Name; optional</CODE><BR>
Is the unique name of the package defining the scope of the variable. A null belongsToPackage is allowed, it means that the variable has global scope. The belongsToPackage concatenated with the name of the variable must provide a unique name for that class within the model.</LI></UL>


<UL>
<LI>formula for <CODE>uniqueName </CODE>(the second branch of the if statement is necessary because a global variable can have package scope) (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>):<BR>
<CODE><BR>
if isNull (belongsToPackage</CODE> <CODE>(globalVariable)) then<BR>
&#9;  uniqueName (globalVariable) = name (globalVariable)<BR>
&#9;else<BR>
&#9;  uniqueName (globalVariable) = belongsToPackage</CODE> <CODE>(globalVariable)<BR>
&#9;    + "::" + name (globalVariable)</LI></UL>

</CODE><P>CDIF Example:</P>
<PRE>(GlobalVariable FM23<BR>
&#9;(name "TRUE")<BR>
&#9;(sourceAnchor #[file "factory.h" start 287 end 291|]#)<BR>
&#9;(declaredType "int")<BR>
&#9;(declaredClass "")<BR>
&#9;(accessControlQualifier "public")<BR>
&#9;(uniqueName "TRUE")<BR>
)</PRE>
<P>&nbsp;</P>
<H3><A NAME="_Toc460240160">5.13. ImplicitVariable</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">ImplicitVariable</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToContext (): Qualifier</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624955"><A NAME="_Toc460240205">Figure 17: ImplicitVariable</A></A></P>
</B><P>An <CODE>ImplicitVariable</CODE> represents the definition in source code of context dependent reference to a memory location (i.e., 'this' in C++ and Java, 'self' and 'super' in Smalltalk). What exactly constitutes such a definition is a language dependent issue.  </P>
<P>ImplicitVariable is a concrete class inheriting from StructuralEntity . Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToContext</CODE> <CODE>: Qualifier; optional</CODE><BR>
Is a string with a language dependent interpretation, that defines a possible scope of the variable. A null belongsToContext is allowed, it means that the variable has global scope. The belongsToContext concatenated with the name of the variable must provide a unique name for that variable within the model.</LI>
<LI>formula for uniqueName (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>):</LI></UL>

<PRE>&#9;if isNull (<CODE>belongsToContext</CODE> (implicitVariable)) then<BR>
&#9;  uniqueName (implicitVariable) = name (implicitVariable)<BR>
&#9;else<BR>
&#9;  uniqueName (implicitVariable) = <BR>
&#9;    <CODE>belongsToContext</CODE> (implicitVariable)<BR>
&#9;      + "." + name (implicitVariable)</PRE>
<P>Example of an implicit variable super:</P>
<PRE>MotifWidget.print () {<BR>
&#9;super.print();<BR>
&#9;System.out.print(" Motif");<BR>
}</PRE>
<P>In CDIF: </P>
<PRE>(ImplictVariable FM77<BR>
&#9;(name "super")<BR>
&#9;(declaredType "gui::Widget")<BR>
&#9;(declaredClass "gui::Widget")<BR>
&#9;(belongsToContext "gui::MotifWidget")<BR>
&#9;(uniqueName "gui::MotifWidget.super")<BR>
)</PRE>
<H3><A NAME="_Toc460240161">5.14. LocalVariable</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">LocalVariable</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToBehaviour (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624956"><A NAME="_Toc460240206">Figure 18: LocalVariable</A></A></P>
</B><P>A <CODE>LocalVariable</CODE> represents the definition in source code of a variable defined locally to a behavioural entity. What exactly constitutes such a definition is a language dependent issue.  </P>
<P>LocalVariable is a concrete class inheriting from StructuralEntity . Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToBehaviour: Name; mandatory</CODE><BR>
Is a name referring to the <CODE>BehaviouralEntity</CODE> owning the variable. It uses the uniqueName of this entity as a reference.</LI>
<LI>formula for uniqueName (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>):</LI></UL>

<PRE>&#9;uniqueName (localVar) =  belongsToBehaviour (localVar) +<BR>
&#9;  "." + name (localVar)</PRE>
<P>Example of a local variable position_:</P>
<PRE>Class ScrollBar {<BR>
&#9;computePosition(int x,int y,int width,int height) {<BR>
&#9;&#9;int position_;<BR>
&#9;&#9;. . .<BR>
&#9;}<BR>
}</PRE>
<P>In CDIF:</P>
<PRE>(LocalVariable FM76<BR>
&#9;(name "position_")<BR>
&#9;(sourceAnchor #[file "factory.h" start 85 end 89|]#)<BR>
&#9;(declaredType "int")<BR>
&#9;(declaredClass "")<BR>
&#9;(belongsToBehaviour "ScrollBar.computePosition(int,int,int,int)")<BR>
&#9;(uniqueName<BR>
&#9;  "gui::ScrollBar.computePosition(int,int,int,int).position_ ")<BR>
)</PRE>
<H3><A NAME="_Toc460240162">5.15. FormalParameter</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">FormalParameter</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToBehaviour (): Name<BR>
position (): Index</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624957"><A NAME="_Ref457645719"><A NAME="_Toc460240207">Figure 19: FormalParameter</A></A></A></P>
</B><P>A <CODE>FormalParameter</CODE> represents the definition in source code of a formal parameter, i.e. the declaration of what a behavioural entity expects as an argument. What exactly constitutes such a definition is a language dependent issue.  </P>
<P>FormalParameter is a concrete class inheriting from StructuralEntity . Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToBehaviour: Name; mandatory</CODE><BR>
Is a name referring to the <CODE>BehaviouralEntity</CODE> owning the variable. It uses the uniqueName of this entity as a reference.</LI>
<CODE><LI>position: Index; mandatory</CODE><BR>
The position of the parameter in the list of parameters.  Language plug-ins should specify what the position of a parameter is and this should be consistent the position attribute of Argument (see page <A HREF="#_Ref457645065">*</A>).</LI>
<LI>formula for uniqueName (see also 4.4. Naming Conventions - p. <A HREF="#namingConventions">*</A>):</LI></UL>

<PRE>&#9;uniqueName (formalPar) =  belongsToBehaviour (formalPar) +<BR>
&#9;  "." + name (formalPar)</PRE>
<P>Example (<CODE>w</CODE> is the formal parameter):</P>
<CODE><PRE>Window::addWidget(Widget&amp; w) { ...... };</PRE>
</CODE><P>In CDIF:</P>
<PRE>(FormalParameter FM41<BR>
&#9;(name "w")<BR>
&#9;(declaredType "gui::Widget&amp;")<BR>
&#9;(declaredClass "gui::Widget")<BR>
&#9;(belongsToBehaviour "gui::Window.addWidget(Widget&amp;)")<BR>
&#9;(position 1)<BR>
&#9;(uniqueName "gui::Window.addWidget(Widget&amp;).w")<BR>
)</PRE>
<H3><A NAME="_Toc460240163">5.16. InheritanceDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">InheritanceDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>subclass (): Name<BR>
superclass (): Name<BR>
accessControlQualifier (): Qualifier<BR>
index (): Index</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624948"><A NAME="_Toc460240208">Figure 20: InheritanceDefinition</A></A></P>
</B><P>An <CODE>InheritanceDefinition</CODE> represents the definition in source code of an inheritance association between two classes. One class then plays the role of the superclass, the other plays the role of the subclass. What exactly constitutes such a definition is a language dependent issue.  </P>
<P>InheritanceDefinition is a concrete class inheriting from Association . Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>subclass: Name; mandatory</CODE><BR>
Is a name referring to the class that inherits. It uses the uniqueName of the class as a reference.</LI>
<CODE><LI>superclass: Name; mandatory</CODE><BR>
Is a name referring to the class that is inherited from. It uses the uniqueName of the class as a reference.</LI>
<CODE><LI>accessControlQualifier: Qualifier; optional</CODE><BR>
Is a string with a language dependent interpretation, that defines how subclasses access their superclasses (for instance, 'public', 'private').</LI>
<CODE><LI>index: Index; optional</CODE><BR>
In languages with multiple inheritance, this is the position of the superclass in the list of superclasses of one subclass. Usually this will have a null value, but it may be necessary for OO languages with multiple inheritance that resolve name collisions via the order of the superclasses (e.g., CLOS).</LI></UL>

<P>CDIF Example of an inheritance relationship between <CODE>Scrollbar</CODE> and its superclass <CODE>Widget</CODE>:</P>
<PRE>(InheritanceDefinition FM27<BR>
&#9;(subclass "gui::ScrollBar")<BR>
&#9;(superclass "gui::Widget")<BR>
&#9;(accessControlQualifier "public")<BR>
&#9;(index 1)<BR>
)</PRE>
<H3><A NAME="_Toc460240164">5.17. Access</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">Access</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>accesses (): Name<BR>
accessedIn (): Name<BR>
isAccessLValue (): Boolean </TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624949"><A NAME="_Toc460240209">Figure 21: Access</A></A></P>
</B><P>An <CODE>Access</CODE> represents the definition in source code of a <CODE>BehaviouralEntity</CODE> accessing a <CODE>StructuralEntity</CODE>. Depending on the level of extraction (see Table 1, p. <A HREF="#_Ref415979649">*</A>), that <CODE>StructuralEntity</CODE> may be an attribute, a local variable, an argument, a global variable. What exactly constitutes such a definition is a language dependent issue. However, when the same structural entity is accessed more than once in a method body, then parsers should generate a separate access-association for each occurrence.</P>
<P>Access is a concrete class inheriting from Association . Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>accesses: Name; mandatory</CODE><BR>
Is a name referring to the variable being accessed. It uses the uniqueName of the variable as a reference.</LI>
<CODE><LI>accessedIn: Name; mandatory</CODE><BR>
Is a name referring to the method doing the access. It uses the uniqueName of the method as a reference.</LI>
<CODE><LI>isAccessLValue: Boolean; optional</CODE><BR>
Is a predicate telling whether the value was accessed as Lvalue, i.e. a location value or a value on the left side of an assignment. When the predicate is true, the memory location denoted by the variable might change its value; false means that the contents of the memory location is read; null means that it is unknown.<BR>
Note that LValue is the inverse of RValue.</LI></UL>

<P>Example of the method <CODE>print()</CODE> accessing <CODE>wTop (both defined in class Widget)</CODE>:</P>
<CODE><PRE>virtual print () { cout &lt;&lt; "top of widget " &lt;&lt; wTop; };</PRE>
</CODE><P>In CDIF:</P>
<PRE>(Access FM18<BR>
&#9;(accesses "gui::Widget.wTop")<BR>
&#9;(accessedIn "gui::Widget.print()")<BR>
&#9;(isAccessLValue -FALSE-)<BR>
)</PRE>
<H3><A NAME="_Toc460240165">5.18. Invocation</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<B><P ALIGN="CENTER">Invocation</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>invokedBy (): Name<BR>
invokes (): Qualifier<BR>
base (): Name<BR>
candidatesAt (pos Integer): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624950"><A NAME="_Toc460240210">Figure 22: Invocation</A></A></P>
</B><P>An <CODE>Invocation</CODE> represents the definition in source code of a <CODE>BehaviouralEntity</CODE> invoking another <CODE>BehaviouralEntity</CODE>. What exactly constitutes such a definition is a language dependent issue. However, when the same behavioural entity is invoked more than once in a method body, then parsers should generate a separate invocation-association for each occurrence.</P>
<P>It is important to note that due to polymorphism, there exists at parse time a one-to-many relationship between the invocation and the actual entity invoked: a method, for instance, might be defined on a certain class, but at runtime actually invoked on an instance of a subclass of this class. This explains the presence of the <CODE>base attribute and the</CODE>  <CODE>candidates</CODE> aggregation.</P>
<P>Invocation is a concrete class inheriting from Association. Besides inherited attributes, it has the following attributes:</P>

<UL>
<CODE><LI>invokedBy: Name; mandatory</CODE><BR>
Is a name referring to the <CODE>BehaviouralEntity</CODE> doing the invocation. It uses the uniqueName of the entity as a reference.</LI>
<CODE><LI>invokes: Qualifier; mandatory</CODE><BR>
Is a qualifier holding the signature of the <CODE>BehaviouralEntity</CODE> invoked. Due to polymorphism, the signature of the invoked <CODE>BehaviouralEntity</CODE> is not enough to assess which <CODE>BehaviouralEntity</CODE> is actually invoked. Further analysis based on the arguments is necessary. Concatenated with the <CODE>base attribute this attribute constitutes the unique name of a behavioural entity.</LI>
<LI>base: Name; optional</CODE><BR>
Is the unique name of the entity where the invoked entity is defined on. Null means unknown and an empty string means the attribute has no base (the invoked entity may be a global function). Together with the <CODE>invokes attribute, this attribute constitutes the unique name of a behavioural entity.</LI>
<LI>candidates: 0 .. N Name; optional</CODE><BR>
Is a multi-valued attribute holding a number of names of <CODE>BehaviouralEntities</CODE>. Each  name refers to a <CODE>BehaviouralEntity</CODE> that may be the actual one invoked at run-time. See appendix "A. Clarifications on the CDIF Encoding" - p.<A HREF="#MultivaluedStrings">*</A> for a description of multi-valued strings in CDIF.</LI></UL>

<P>CDIF Example. The method <CODE>Widget.print()</CODE> is invoked according to the source code. The actual method invoked at runtime, however, could be the <CODE>print()</CODE> method of one of the subclasses <CODE>MotifWidget</CODE> or <CODE>SwingWidget</CODE>:</P>
<PRE>(Invocation FM35<BR>
&#9;(invokedBy "gui::ScrollBar.print()")<BR>
&#9;(invokes "print()")<BR>
&#9;(base "gui::Widget")<BR>
&#9;(candidates&#9;#[gui::Widget.print()|]#,<BR>
&#9;&#9;&#9;#[motif::MotifWidget.print()|]#,<BR>
&#9;&#9;&#9;#[javax::swing::SwingWidget.print()|]#)<BR>
)</PRE>
<H3><A NAME="_Toc460240166">5.19. Argument, ExpressionArgument &amp;  AccessArgument</A></H3>
<P><A NAME="_Ref410614674"><A NAME="_Toc410624951"><IMG SRC="Image215.gif" WIDTH=595 HEIGHT=188></P>
<B><P><A NAME="_Ref457645065"><A NAME="_Toc460240211">Figure 23: Argument, ExpressionArgument &amp; AccessArgument</A></A></A></A></P>
</B><P>An <CODE>Argument</CODE> represents the passing of an argument when invoking a <CODE>BehaviouralEntity</CODE>. What exactly constitutes such a definition is a language dependent issue. The model distinguishes between two kind of arguments, an ExpressionArgument or an AccessArgument. The former means that some complex expression is passed, in that case the contents of the expression is not further specified. The latter means that a reference to a <CODE>StructuralEntity</CODE> is passed, thus involving an Access to the corresponding structural entity, hence a reference to the corresponding Access is stored within the AccessArgument.</P>
<P>Both ExpressionArgument and AccessArgument are concrete classes inheriting from Argument. Argument is an abstract class inheriting from Object. Besides inherited attributes, Argument has the following attributes:</P>

<UL>
<CODE><LI>position: Index; mandatory</CODE><BR>
The position of the argument in the list of arguments. Language plug-ins should specify what the position of a argument is and this should be consistent the position attribute of FormalParameter (see page <A HREF="#_Ref457645719">*</A>).</LI></UL>


<UL>
<CODE><LI>isReceiver: Boolean; mandatory<BR>
</CODE>Is a predicate telling whether this argument plays the role of the receiver in the containing invocation. Knowing which argument plays the role of the receiver may help resolving polymorph invocations.</LI></UL>

<P>Example of a method <CODE>print() with two method invocations and their arguments. Note that the first call has one argument (namely super) and the second call has two (namely System.out and " Motif"</CODE>:</P>
<PRE>MotifWidget.print () {<BR>
&#9;super.print();<BR>
&#9;System.out.print(" Motif");<BR>
}</PRE>
<P>In CDIF: </P>
<PRE>#| FM90 expresses the access of the super implicit variable |#
(Access FM90<BR>
&#9;(accesses "gui::MotifWidget.super")<BR>
&#9;(accessedIn "gui::MotifWidget.print()")<BR>
)
#| FM91 and FM92 express the passing of super as an argument to print |#
(AccessArgument FM91<BR>
&#9;(position 1)<BR>
&#9;(isReceiver -TRUE-)<BR>
)<BR>
(AccessArgument.HasAccess.Access FM92 FM91 FM90)
#| FM101 and FM102 express the invocation of print with argument super.<BR>
   Note that gui::Widget is the only candidate of the invocation. |#
(Invocation FM101<BR>
&#9;(invokedBy "gui::MotifWidget.print()")<BR>
&#9;(invokes "print()")<BR>
&#9;(base "gui::Widget")<BR>
&#9;(candidates #[gui::Widget|]#)<BR>
)<BR>
(Invocation.HasArgument.Argument FM102 FM101 FM91)
#| FM110 expresses the access of the System.out attribute |#
(Access FM110<BR>
&#9;(accesses "java::lang::System.out")<BR>
&#9;(accessedIn "gui::MotifWidget.print()")<BR>
)
#| FM111 and FM112 express the passing of System.out as argument to print|#
(AccessArgument FM111<BR>
&#9;(position 1)<BR>
&#9;(isReceiver -TRUE-)<BR>
)<BR>
(AccessArgument.HasAccess.Access FM112 FM111 FM110)
#| FM120 expresses the passing of the constant value " Motif" as argument to print |#
(ExpressionArgument FM120<BR>
&#9;(position 2)<BR>
&#9;(isReceiver -FALSE-)<BR>
)<BR>
<BR>
#| FM121, FM122 and FM123 express the invocation of print with arguments System.out and " Motif" |#
(Invocation FM121<BR>
&#9;(invokedBy "gui::MotifWidget.print()")<BR>
&#9;(invokes "print()")<BR>
&#9;(base "PrintStream")<BR>
)<BR>
(Invocation.HasArgument.Argument FM122 FM121 FM111)<BR>
(Invocation.HasArgument.Argument FM123 FM121 FM120)</PRE>
<H2><A NAME="_Toc460240167">6) Open Questions</A></H2>
<H3><A NAME="_Toc460240168">6.1. Why not UML? Why not CORBA/IDL?</A></H3>
<P>For an in depth treatment of the question why UML is not sufficient, we refer the reader to the achievement report addressing this specific issue [<A HREF="#WHYFAMIX">WHYFAMIX</A>], which also appeared as [Deme99]. In brief, the argumentation is as follows:</P>
<P>The unified Modelling Language (UML) [Booc96a] is rapidly becoming the standard modelling language for object-oriented software, even in industry. So, UML is a viable candidate for serving as the data model behind our exchange format. Nevertheless, UML does not include internal dependencies such as method invocations and variable accesses. Those dependencies are necessary in the problem detection and reorganisation phases of the reengineering life cycle (see Figure 1). Thus, choosing UML would violate the requirement of being a sufficient basis for reengineering operations (see "Requirements Specification" - p.<A HREF="#_Ref410210475">*</A>).</P>
<P>However, we relied heavily on UML in the terminology and naming conventions applied in our model to become independent of the implementation language. For example, we talk about attributes instead of members (C++) or instance variable (Smalltalk) and we talk about classes instead of types (Ada).</P>
<P>CORBA is receiving widespread attention as interoperability standard between different object-oriented implementation languages. The IDL (interface description language) is used to specify the external interface of a software component and there are tools that extract IDL from source code. As such, CORBA/IDL is a viable candidate to serve as our exchange format.</P>
<P>However, CORBA/IDL only describes the interface of a software component, and, like UML, not the internal dependencies such as method invocations and variable accesses. Thus, also CORBA/IDL would violate the requirement of being a sufficient basis for reengineering operations (see "Requirements Specification" - p.<A HREF="#_Ref410210475">*</A>).</P>
<H3><A NAME="_Toc460240169">6.2. What about Dynamic Information?</A></H3>
<P>Because of polymorphism, not all method invocations can be resolved at compile time. Also, a model based on source code is not ideal for identifying sequences of interactions between objects. Thus, basing the model solely on static information eliminates some interesting facts about a software system and one might consider including run-time information as well.</P>
<P>For the moment we consider the issue too premature to include in an information exchange standard. The technology is available (i.e., Look for C++, method wrappers for Smalltalk) but is certainly not part of the standard tool repertoire. And extracting run-time information generates such a wealth of data that we cannot assess at this moment what is important enough to maintain.</P>
<H2><A NAME="_Toc460240170">7) References</A></H2>
<H3><A NAME="_Toc460240171">7.1. FAMOOS Internal References</A></H3>
<P>[<A NAME="DETECTM">DETECTM</A>]&#9;FAMOOS Achievement Report DETECTM-A.2.3.2. " Specification of Techniques and Strategies for Problem Detection". Benedikt Schulz, Forschungszentrum Informatik.</P>
<P>[<A NAME="DOCUM">DOCUM</A>]&#9;FAMOOS Achievement Report DOCUM-A.2.3.1. " Documentation and Model Capture Method(Grouping)". Oliver Ciupke, Forschungszentrum Informatik.</P>
<P><A NAME="EVALCDIF">[EVALCDIF]</A>&#9;FAMOOS Achievement Report EVALCDIF "Evaluation of the CDIF Transfer-Format". Thomas Kohler, Daimler-Benz AG.</P>
<P>[<A NAME="REORGOP">REORGOP</A>]&#9;FAMOOS Achievement Report REORGOP-A.2.3.3./A.2.3.4. " Specification of Complex Reengineering Operations and Target Structures ". Joachim Weisbrod, Forschungszentrum Informatik.</P>
<P>[<A NAME="WHYFAMIX">WHYFAMIX</A>]&#9;FAMOOS Achievement Report WHYFAMIX-A.2.4.2 "Why FAMIX -- Shortcomings of UML for Round-trip Engineering". Serge Demeyer, St&eacute;phane Ducasse, Sander Tichelaar, University of Berne. See <A HREF="http://www.iam.unibe.ch/~famoos/FAMIX/">http://www.iam.unibe.ch/~famoos/FAMIX/</A>.</P>
<H3><A NAME="_Toc460240172">7.2. External References</A></H3>
<P>[<A NAME="UML96">Booc96a</A>]&#9;Booch, G., Jacobson, I. and Rumbaugh, J, "The Unified Modelling Language for Object-Oriented Development". See <A HREF="http://www.rational.com/">http://www.rational.com/</A>.</P>
<P>[<A NAME="CDIF94a">CDIF94a</A>]&#9;CDIF Technical Committee, "CDIF Framework for Modelling and Extensibility", Electronic Industries Association, EIA/IS-107, January 1994. See <A HREF="http://www.cdif.org/">http://www.eigroup.org/cdif/index.html</A>.</P>
<P>[<A NAME="CDIFSyntax">CDIF94b</A>]&#9;CDIF Technical Committee, "CDIF Transfer Format Syntax SYNTAX.1", Electronic Industries Association, EIA/IS-109, January 1994. See <A HREF="http://www.cdif.org/">http://www.eigroup.org/cdif/index.html</A>.</P>
<P>[<A NAME="CDIFEnc">CDIF94c</A>]&#9;CDIF Technical Committee, "CDIF Transfer Format Encoding ENCODING.1", Electronic Industries Association, EIA/IS-110, January 1994. See <A HREF="http://www.cdif.org/">http://www.eigroup.org/cdif/index.html</A>.</P>
<P>[<A NAME="Deme99">Deme99</A>]&#9;Serge Demeyer, St&eacute;phane Ducasse and Sander Tichelaar, "Why Unified is not Universal ? UML Shortcomings for Coping with Round-trip Engineering", Proceedings UML'99 (The Second International Conference on The Unified Modeling Language), Bernhard Rumpe (Ed.), LNCS ????, Springer-Verlag, Kaiserslautern, Germany, October, 1999.</P>
<P>[<A NAME="XMI98">XMI98</A>]&#9;OMG, "XML Metadata Interchange (XMI)", OMG Document ad/98-10-05, October 1998. See <A HREF="http://www.omg.org/">http://www.omg.org/</A>.</P>
<H1>&nbsp;</H1><DIR>

<H1><A NAME="_Toc460240173">Appendices</A></H1></DIR>

<H2><A NAME="ClarifyCDIF"><A NAME="_Toc460240174">A. Clarifications on the CDIF Encoding</A></A></H2>
<P>To satisfy the requirements for information exchange between tools (see "Requirements Specification" - p.<A HREF="#_Ref410210475">*</A>), we choose the CDIF standard as the basis for transferring information between tools. This choice at least satisfies the "supports industry standards" and the "extensible" requirements. Moreover, CDIF is open with respect to the specific format for a transfer, or to state it in CDIF terminology allows for different syntaxes and encodings.  By adopting the CDIF syntax SYNTAX.1 with the plain text encoding ENCODING.1 (see [CDIF94b] and [CDIF94c]), we also satisfy the "human readable" and "simple to process" requirements.</P>
<P>CDIF has proven to be a proper solution for our purposes. However, the explicit definition of associations and the lack of multi-valued string attributes leads to verbose transfers that are difficult to read for humans and hinders the merging of information coming from different sources. Also, there are some things we found unclear while reading the CDIF specifications.  Therefore, this part of the appendix describes our interpretation of the CDIF standard.</P>
<H3><A NAME="_Toc460240175">A.1. Avoid Explicit Relationships</A></H3>
<P>We avoid explicit relationships for the core model (see Figure 3).This might seem a bit strange at first, but our experiments have shown that heavy use of  CDIF relationships compromises the readability of the document a lot. First of all, information gets scattered around in the transfer instead of being nicely encapsulated in the entity it belongs to. And second, CDIF relationships employ meaningless identifiers unique within a transfer only instead of references by name. The latter also hinders the combination of information from different sources. </P>
<P>Below is an example of how we encapsulate a "belongsToClass" attribute in Method, instead of defining an explicit "Class.HasMethod.Method" relationship and instantiating it for every Class/Method association. Thus we get ...</P>
<PRE>&#9;(Method FM35<BR>
&#9;&#9;(name "print")<BR>
&#9;&#9;(belongsToClass "Widget")<BR>
&#9;&#9;...<BR>
&#9;)</PRE>
<P>instead of</P>
<PRE>&#9;(Class FM17<BR>
&#9;&#9;(name "Widget")<BR>
&#9;&#9;...<BR>
&#9;)
&#9;...<BR>
&#9;(Method FM35<BR>
&#9;&#9;(name "print")<BR>
&#9;&#9;...<BR>
&#9;)
&#9;...<BR>
&#9;(Class.HasMethod.Entity FM56 FM17 FM35)</PRE>
<H3><A NAME="MultivaluedStrings"><A NAME="_Toc460240176">A.2. Allow multi-valued String Attributes</A></A></H3>
<P>To deal with many-to-1 relationships we need multi-valued string attributes. Indeed, we avoid explicit relationships to enhance the readability of a document and to ease combination of information from different sources. However, using a string attribute to encode a relationship (like we did above) only allows for 1-to-many relationships.</P>
<P>CDIF provides IntegerList and PointList in its set of basic data types, thus in principle CDIF permits the use of multi-valued attributes. Unfortunately, there is no basic data type that copes with multi-valued strings. Yet, the CDIF "TextValue" data type comes near, thus in some rare occasions we interpret "TextValue" as a multi-valued text attribute.</P>
<P>In the original CDIF standard, a TextValue denotes a set of characters which is divided into blocks with a maximum of 1024 characters. The beginning of each block is marked by "#[" while the end is marked by "]#". The actual value of the text is the concatenation of the blocks.</P>
<P>To represent a multi-valued string attribute with a TextValue, we interpret each block in a TextValue as a separate string. Also, we require that each one of those strings must append a special delimiter character (which is "|") to its end so that the original multi-valued strings can be retrieved from the concatenated blocks. In the (unlikely) situation that a &quot;|&quot; appears in a string value it should be escaped with &quot;\|&quot;. Thus we get ...</P>
<PRE>&#9;(Invocation FM35<BR>
&#9;&#9;(invokedBy "ScrollBar.print()")<BR>
&#9;&#9;(invokes "print()")<BR>
&#9;&#9;(candidates&#9;#[Widget.print()|]#,<BR>
&#9;&#9;&#9;&#9;#[MotifWidget.print()|]#,<BR>
&#9;&#9;&#9;&#9;#[SwingWidget.print()|]#)<BR>
&#9;)</PRE>
<P>instead of (using CDIF relationships):</P>
<PRE>&#9;(Invocation FM35<BR>
&#9;&#9;(invokedBy "ScrollBar.print()")<BR>
&#9;&#9;(invokes "print()")<BR>
&#9;)
&#9;...
&#9;(Candidate FM45<BR>
&#9;&#9;(value "Widget.print()")<BR>
&#9;)
&#9;(Candidate FM46<BR>
&#9;&#9;(value "MotifWidget.print()")<BR>
&#9;)
&#9;(Candidate FM47<BR>
&#9;&#9;(value "SwingWidget.print()")<BR>
&#9;)<BR>
<BR>
&#9;...<BR>
<BR>
&#9;(Invocation.HasCandidate.Candidate FM87 FM35 FM45) &#9;(Invocation.HasCandidate.Candidate FM88 FM35 FM46)<BR>
&#9;(Invocation.HasCandidate.Candidate FM89 FM35 FM47)</PRE>
<H2><A NAME="Howtoextend"><A NAME="_Toc460240177">B. How to extend the model</A></A></H2>
<P>Considering the "Conception of the FAMIX Model" (see Figure 2), we see that there are two situations in which the model will be extended. The first corresponds with a language-specific plug-in, while the second corresponds with a tool-specific addition.  Considering the model itself (see Figure 4 and Figure 5), there are two possible kinds of extensions. One is to add attributes to existing classes, the other is to create new classes.</P>
<P>To ensure that the various tools will be able to deal with all extensions, it is necessary to specify what and how to extend. This is the purpose of the following rules.</P>
<OL>

<LI>Language-specific plug-ins are allowed to create new classes (for instance, new kinds of entities and associations) and add new attributes. Tool specific additions are restricted to the addition of new attributes.</LI>
<LI>Additional attributes should <STRONG>NOT</STRONG> be introduced via subclasses.</LI></OL>

<P>The motivation behind the first rule is that reengineering tools should always be able to work together. A reengineering tool that is dependent of extra classes will complicate co-operation, hence the restriction.</P>
<P>Because the second rule is counter-intuitive, we will elaborate on the motivation. Indeed, since CDIF offers inheritance, extensions to the model are tempted to create subclasses of existing classes to add new attributes. However, such an approach implies that all tools that process a CDIF transfer must know about the extra subclasses defined in an extension, hence must completely analyse the meta-model part of a CDIF transfer.</P>
<P>As an example consider an extension for a C++ class, where we add an attribute called "friends", which is a multi-valued attribute holding the names of all friend classes and methods of a certain class. If we define the new attribute as an attribute of "Class", the CDIF transfer will contain a class entity with a potentially unknown attribute. Tools that do not know about this extra attribute may safely ignore it. For instance, a simple querying tool (e.g., grep) will be able extract information out of a transfer (see Figure 24 (a)) without worrying about the extra attribute. However, if we define a new subclass C++Class, which contains the additional attribute, a transfer will contain "C++Class" entities. Tools that do not know about this subclass will break because they do not know the extension and therefore do not recognise the C++Class (see Figure 24 (b)).</P>
<P><IMG SRC="Image229.gif" WIDTH=541 HEIGHT=269></P>
<B><P><A NAME="_Ref423249659"><A NAME="_Toc460240212">Figure 24</A>: Example of an extension.<BR>
(a) without subclassing, correct (b) with subclassing, incorrect.</A></P>
</B><H2><A NAME="_Toc460240178">C. The FAMIX Model in CDIF</A></H2>
<P>The FAMIX Model is defined in the subject area FAMOOS. It only uses the Foundation subject area, which is the basic CDIF subject-area that defines an entity-relationship model and is mandatory to use by all models.</P>
<P>For the complete definition of the meta-model in CDIF, check<BR>
&#9;<A HREF="http://www.iam.unibe.ch/~famoos/FAMIX/">http://www.iam.unibe.ch/~famoos/FAMIX/</A></P>
<H2>&nbsp;</H2>
<H2><A NAME="_Toc460240179">D. The complete FAMIX Model</A></H2>
<P><IMG SRC="Image230.gif" WIDTH=334 HEIGHT=847></P><DIR>

<H1 ALIGN="CENTER">&#9;<A NAME="_Toc460240180"><FONT FACE="Arial" SIZE=5>Cover Pages</A></H1></DIR>

</FONT><B><FONT FACE="Arial" SIZE=4><P ALIGN="CENTER">Achievement A2.4.1</P>
<P ALIGN="CENTER"></FONT><FONT FACE="Arial" SIZE=5>FAMIX 2.0</P>
</B></FONT><H2><A NAME="_Toc460240181">1) Identification</A></H2>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=590>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Project Id:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>Esprit IV #21975 &quot;FAMOOS&quot;</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Deliverable Id:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>D 2.2  FINALFHB Final FAMOOS Methodology Handbook</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Date for delivery:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>31.08.99</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Planned date for delivery:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>31.08.99</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>WP(s) contributing to:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>2</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Author(s):</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>S. Demeyer, S. Ducasse, T. Richner, M. Rieger, P. Steyaert, S. Tichelaar</TD>
</TR>
</TABLE>

<H2><A NAME="_Toc460240182">2) Abstract</A></H2>
<I><H2></I>This document defines the exchange model for usage by tool prototypes within the FAMOOS reengineering project. These tools exchange information concerning object-oriented source code. This information is then transferred via flat ASCII streams using the CDIF standard.
<H2>&nbsp;</H2><A NAME="_Toc460240183">3) Keywords</A></H2>
<P>Object-oriented, reengineering, reverse engineering, code repository, round-trip engineering, FAMOOS, FAMIX.</P>
<H2><A NAME="_Toc460240184">4) Version History</A></H2>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=590>
<TR><TD WIDTH="12%" VALIGN="TOP">
<STRONG><P>Ver</STRONG></TD>
<TD WIDTH="13%" VALIGN="TOP">
<STRONG><P>Date</STRONG></TD>
<TD WIDTH="24%" VALIGN="TOP">
<STRONG><P>Editor(s)</STRONG></TD>
<TD WIDTH="51%" VALIGN="TOP">
<STRONG><P>Status &amp; Notes</STRONG></TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">
<P>0.4</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P>17.11.97</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Demeyer; P. Steyaert</TD>
<TD WIDTH="51%" VALIGN="TOP">
<P>First draft version. Released to all the participants of the Ulm-workshop (21.11.97).</TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">
<P>0.5</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P>24.11.97</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Demeyer</TD>
<TD WIDTH="51%" VALIGN="TOP">
<P>Quick tour of revised model; incorporates feedback generated during workshops at FZI (20.11.97) and Daimler-Benz (21.11.97).</TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">
<P>0.6</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P>09.01.98</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Demeyer</TD>
<TD WIDTH="51%" VALIGN="TOP">
<P>Expanded quick tour into a full specification. Changed original document template for convenient generation of HTML.<BR>
Document is now ready for reviewing and defining language plug-ins.</TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">
<P>1.0</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P>30.03.98</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Demeyer</TD>
<TD WIDTH="51%" VALIGN="TOP">
<P>Final release (see below for the details)</TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="88%" VALIGN="TOP" COLSPAN=3>
<P>Final release:</P>

<UL>
<LI>Incorporated feedback given on prior release.</LI>
<LI>Adapted meta-model to be streamlined with CDIF; removed examples, we first need some tool experience with CDIF.</LI>
<LI>Introduced the notion of &quot;level of reification&quot;.</UL>
</TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">
<P>1.1alpha</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P>15.06.98</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Tichelaar</TD>
<TD WIDTH="51%" VALIGN="TOP">
<P>Adapted Model + Included CDIF examples</TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="88%" VALIGN="TOP" COLSPAN=3>

<UL>
<LI>Adapted the model according to feedback on 1.0 version and experiences using the model in tools:<BR>
- shortened some names<BR>
- added Object and Property entity<BR>
- converged meta-meta-model and meta-model in one model<BR>
- changed "level of reification" into  "level of extraction"<BR>
 all kinds of small changes</LI>
<LI>Included CDIF examples and the complete model definition in CDIF as an appendix</UL>
</TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">
<P>1.1</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P>1.07.98</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Tichelaar, S. Demeyer</TD>
<TD WIDTH="51%" VALIGN="TOP">

<UL>
<LI>Extended the model to deal with global functions (i.e., introduce BehaviouralEntity and StructuralEntity).</LI>
<LI>Added appendices about "Clarifications on the CDIF Encoding" and "How to extend the model"</UL>
</TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">
<P>2.0</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P>25.08.99</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Tichelaar, S. Demeyer</TD>
<TD WIDTH="51%" VALIGN="TOP">

<UL>
<LI>Adapted to comments, experience, + bug fixes and clean up</UL>
</TD>
</TR>
<TR><TD WIDTH="12%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="88%" VALIGN="TOP" COLSPAN=3>

<UL>
<LI>isReceiver removed from FormalParameter.</LI>
<LI>Renamed ComplexExpression into ExpressionArgument and SimpleAccess into AccessArgument.</LI>
<LI>Added packages; due to that renamed scopeQualifier into either belongsToPackage or belongsToContext.</LI>
<LI>Clarified that accesses and invocations should include an association for every item accessed or invoked, even when it concerns the same entity.</LI>
<LI>Introduced a Model as a singleton maintaining global information concerning the parsed source code.</LI>
<LI>Introduced a separate section on naming conventions.</LI>
<LI>Bug fixes and clean up.</UL>
</TD>
</TR>
</TABLE>

<H2><A NAME="_Toc460240185">5) Issues for future releases</A></H2>
<P>Some issues couldn't be incorporated in the 2.0 release due to time constraints:</P>

<UL>
<LI>The model needs basic adaptation to incorporate the notion of grouping. </LI></UL>

<H2><A NAME="_Toc460240186">6) Table of Contents</A></H2>
<B><FONT FACE="Times"><P>FAMIX 2.0&#9;</B></FONT><A HREF="#_Toc460240136">*</A><DIR>
<DIR>

<FONT FACE="Times"><P>Abstract&#9;</FONT><A HREF="#_Toc460240137">*</A></P>
<FONT FACE="Times"><P>1) Introduction&#9;</FONT><A HREF="#_Toc460240138">*</A></P>
<FONT FACE="Times"><P>2) Requirements Specification&#9;</FONT><A HREF="#_Toc460240139">*</A></P>
<FONT FACE="Times"><P>3) CDIF Transfer Format&#9;</FONT><A HREF="#_Toc460240140">*</A></P>
<FONT FACE="Times"><P>4) Description of FAMIX&#9;</FONT><A HREF="#_Toc460240141">*</A></P>
<FONT FACE="Times"><P>4.1. The Core Model&#9;</FONT><A HREF="#_Toc460240142">*</A></P>
<FONT FACE="Times"><P>4.2. The abstract part of the model&#9;</FONT><A HREF="#_Toc460240143">*</A></P>
<FONT FACE="Times"><P>4.3. Basic Data Types&#9;</FONT><A HREF="#_Toc460240144">*</A></P>
<FONT FACE="Times"><P>4.4. Naming Conventions&#9;</FONT><A HREF="#_Toc460240145">*</A></P>
<FONT FACE="Times"><P>4.5. Level of Extraction&#9;</FONT><A HREF="#_Toc460240146">*</A></P>
<FONT FACE="Times"><P>5) Definition of FAMIX&#9;</FONT><A HREF="#_Toc460240147">*</A></P>
<FONT FACE="Times"><P>5.1. The abstract part: Object, Entity and Association&#9;</FONT><A HREF="#_Toc460240148">*</A></P>
<FONT FACE="Times"><P>5.2. Model&#9;</FONT><A HREF="#_Toc460240149">*</A></P>
<FONT FACE="Times"><P>5.3. Package&#9;</FONT><A HREF="#_Toc460240150">*</A></P>
<FONT FACE="Times"><P>5.4. Class&#9;</FONT><A HREF="#_Toc460240151">*</A></P>
<FONT FACE="Times"><P>5.5. BehaviouralEntity Hierarchy&#9;</FONT><A HREF="#_Toc460240152">*</A></P>
<FONT FACE="Times"><P>5.6. BehaviouralEntity&#9;</FONT><A HREF="#_Toc460240153">*</A></P>
<FONT FACE="Times"><P>5.7. Method&#9;</FONT><A HREF="#_Toc460240154">*</A></P>
<FONT FACE="Times"><P>5.8. Function&#9;</FONT><A HREF="#_Toc460240155">*</A></P>
<FONT FACE="Times"><P>5.9. StructuralEntity Hierarchy&#9;</FONT><A HREF="#_Toc460240156">*</A></P>
<FONT FACE="Times"><P>5.10. StructuralEntity&#9;</FONT><A HREF="#_Toc460240157">*</A></P>
<FONT FACE="Times"><P>5.11. Attribute&#9;</FONT><A HREF="#_Toc460240158">*</A></P>
<FONT FACE="Times"><P>5.12. GlobalVariable&#9;</FONT><A HREF="#_Toc460240159">*</A></P>
<FONT FACE="Times"><P>5.13. ImplicitVariable&#9;</FONT><A HREF="#_Toc460240160">*</A></P>
<FONT FACE="Times"><P>5.14. LocalVariable&#9;</FONT><A HREF="#_Toc460240161">*</A></P>
<FONT FACE="Times"><P>5.15. FormalParameter&#9;</FONT><A HREF="#_Toc460240162">*</A></P>
<FONT FACE="Times"><P>5.16. InheritanceDefinition&#9;</FONT><A HREF="#_Toc460240163">*</A></P>
<FONT FACE="Times"><P>5.17. Access&#9;</FONT><A HREF="#_Toc460240164">*</A></P>
<FONT FACE="Times"><P>5.18. Invocation&#9;</FONT><A HREF="#_Toc460240165">*</A></P>
<FONT FACE="Times"><P>5.19. Argument, ExpressionArgument &amp;  AccessArgument&#9;</FONT><A HREF="#_Toc460240166">*</A></P>
<FONT FACE="Times"><P>6) Open Questions&#9;</FONT><A HREF="#_Toc460240167">*</A></P>
<FONT FACE="Times"><P>6.1. Why not UML? Why not CORBA/IDL?&#9;</FONT><A HREF="#_Toc460240168">*</A></P>
<FONT FACE="Times"><P>6.2. What about Dynamic Information?&#9;</FONT><A HREF="#_Toc460240169">*</A></P>
<FONT FACE="Times"><P>7) References&#9;</FONT><A HREF="#_Toc460240170">*</A></P>
<FONT FACE="Times"><P>7.1. FAMOOS Internal References&#9;</FONT><A HREF="#_Toc460240171">*</A></P>
<FONT FACE="Times"><P>7.2. External References&#9;</FONT><A HREF="#_Toc460240172">*</A></P></DIR>

<B><FONT FACE="Times"><P>Appendices&#9;</B></FONT><A HREF="#_Toc460240173">*</A></P><DIR>

<FONT FACE="Times"><P>A. Clarifications on the CDIF Encoding&#9;</FONT><A HREF="#_Toc460240174">*</A></P>
<FONT FACE="Times"><P>A.1. Avoid Explicit Relationships&#9;</FONT><A HREF="#_Toc460240175">*</A></P>
<FONT FACE="Times"><P>A.2. Allow multi-valued String Attributes&#9;</FONT><A HREF="#_Toc460240176">*</A></P>
<FONT FACE="Times"><P>B. How to extend the model&#9;</FONT><A HREF="#_Toc460240177">*</A></P>
<FONT FACE="Times"><P>C. The FAMIX Model in CDIF&#9;</FONT><A HREF="#_Toc460240178">*</A></P>
<FONT FACE="Times"><P>D. The complete FAMIX Model&#9;</FONT><A HREF="#_Toc460240179">*</A></P></DIR>

<B><FONT FACE="Arial"><P>Cover Pages</FONT><FONT FACE="Times">&#9;</B></FONT><A HREF="#_Toc460240180">*</A></P><DIR>

<FONT FACE="Times"><P>1) Identification&#9;</FONT><A HREF="#_Toc460240181">*</A></P>
<FONT FACE="Times"><P>2) Abstract&#9;</FONT><A HREF="#_Toc460240182">*</A></P>
<FONT FACE="Times"><P>3) Keywords&#9;</FONT><A HREF="#_Toc460240183">*</A></P>
<FONT FACE="Times"><P>4) Version History&#9;</FONT><A HREF="#_Toc460240184">*</A></P>
<FONT FACE="Times"><P>5) Issues for future releases&#9;</FONT><A HREF="#_Toc460240185">*</A></P>
<FONT FACE="Times"><P>6) Table of Contents&#9;</FONT><A HREF="#_Toc460240186">*</A></P>
<FONT FACE="Times"><P>7) List of Figures&#9;</FONT><A HREF="#_Toc460240187">*</A></P>
<FONT FACE="Times"><P>8) List of Tables&#9;</FONT><A HREF="#_Toc460240188">*</A></P>
<P>&nbsp;</P></DIR>
</DIR>
</P>
<H2><A NAME="_Toc460240187">7) List of Figures</A></H2>
<FONT FACE="Times"><P>Figure 1: FAMOOS reengineering life cycle&#9;</FONT><A HREF="#_Toc460240189">*</A><DIR>
<DIR>

<FONT FACE="Times"><P>Figure 2: Conception of the FAMIX Model&#9;</FONT><A HREF="#_Toc460240190">*</A></P>
<FONT FACE="Times"><P>Figure 3: The Core Model&#9;</FONT><A HREF="#_Toc460240191">*</A></P>
<FONT FACE="Times"><P>Figure 4:  Basic structure of the complete model&#9;</FONT><A HREF="#_Toc460240192">*</A></P>
<FONT FACE="Times"><P>Figure 5: The basic classes Object, Entity and Association&#9;</FONT><A HREF="#_Toc460240193">*</A></P>
<FONT FACE="Times"><P>Figure 6: Model&#9;</FONT><A HREF="#_Toc460240194">*</A></P>
<FONT FACE="Times"><P>Figure 7: Package&#9;</FONT><A HREF="#_Toc460240195">*</A></P>
<FONT FACE="Times"><P>Figure 8: Class&#9;</FONT><A HREF="#_Toc460240196">*</A></P>
<FONT FACE="Times"><P>Figure 9: BehaviouralEntity Hierarchy&#9;</FONT><A HREF="#_Toc460240197">*</A></P>
<FONT FACE="Times"><P>Figure 10: BehaviouralEntity&#9;</FONT><A HREF="#_Toc460240198">*</A></P>
<FONT FACE="Times"><P>Figure 11: Method&#9;</FONT><A HREF="#_Toc460240199">*</A></P>
<FONT FACE="Times"><P>Figure 12: Function&#9;</FONT><A HREF="#_Toc460240200">*</A></P>
<FONT FACE="Times"><P>Figure 13: StructuralEntity Hierarchy&#9;</FONT><A HREF="#_Toc460240201">*</A></P>
<FONT FACE="Times"><P>Figure 14: StructuralEntity&#9;</FONT><A HREF="#_Toc460240202">*</A></P>
<FONT FACE="Times"><P>Figure 15: Attribute&#9;</FONT><A HREF="#_Toc460240203">*</A></P>
<FONT FACE="Times"><P>Figure 16: GlobalVariable&#9;</FONT><A HREF="#_Toc460240204">*</A></P>
<FONT FACE="Times"><P>Figure 17: ImplicitVariable&#9;</FONT><A HREF="#_Toc460240205">*</A></P>
<FONT FACE="Times"><P>Figure 18: LocalVariable&#9;</FONT><A HREF="#_Toc460240206">*</A></P>
<FONT FACE="Times"><P>Figure 19: FormalParameter&#9;</FONT><A HREF="#_Toc460240207">*</A></P>
<FONT FACE="Times"><P>Figure 20: InheritanceDefinition&#9;</FONT><A HREF="#_Toc460240208">*</A></P>
<FONT FACE="Times"><P>Figure 21: Access&#9;</FONT><A HREF="#_Toc460240209">*</A></P>
<FONT FACE="Times"><P>Figure 22: Invocation&#9;</FONT><A HREF="#_Toc460240210">*</A></P>
<FONT FACE="Times"><P>Figure 23: Argument, ExpressionArgument &amp; AccessArgument&#9;</FONT><A HREF="#_Toc460240211">*</A></P>
<FONT FACE="Times"><P>Figure 24: Example of an extension. (a) without subclassing, correct (b) with subclassing, incorrect.&#9;</FONT><A HREF="#_Toc460240212">*</A></P>
<P>&nbsp;</P></DIR>
</DIR>
 </P>
<H2><A NAME="_Toc460240188">8) List of Tables</A></H2>
<FONT FACE="Times"><P>Table 1: Levels of Extraction&#9;</FONT><A HREF="#_Toc460240213">*</A>
<P>&nbsp;</P></P></BODY>
</HTML>
