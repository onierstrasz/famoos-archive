<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>FAMOOS/Exchange Model</TITLE>
<META NAME="keywords" CONTENT="Object-oriented, reengineering, reverse engineering, code repository, FAMOOS.">
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#800080">

<OL>

<H1><LI><A NAME="DocumentTitle"><A NAME="_Toc415978392">Definition of a Common Exchange Model</A></A></LI></H1></OL>

<ADDRESS>Version 1.0 -- Last Modified: Tuesday, March 31, 1998</ADDRESS>
<ADDRESS>Available on the WWW at: <A HREF="http://www.iam.unibe.ch/~famoos/InfoExchFormat/">http://www.iam.unibe.ch/~famoos/InfoExchFormat</A>/</ADDRESS>
<H2><A NAME="_Toc415978393">Abstract</A></H2>
<ADDRESS><A NAME="Abstract">This document defines the exchange model for usage by tool prototypes within the FAMOOS re-engineering project. The model is based upon the CDIF standard so that it can be transferred via flat ASCII streams.</ADDRESS>
<P></A>All comments are welcome: <A HREF="file:///C:/Users/famoos/Reports/AR241/famoos@iam.unibe.ch">famoos@iam.unibe.ch</A>.</P>
<H2><A NAME="_Toc415978394">1) Introduction</A></H2>
<P>The FAMOOS project (<A HREF="http://www.iam.unibe.ch/~famoos/">http://www.iam.unibe.ch/~famoos/</A>) aims to develop a re-engineering method for transforming object-oriented legacy code into frameworks. The re-engineering method itself is defined around a life cycle model (see also Figure 1).</P>
<OL>

<LI>Model Capture: documenting and understanding the software system</LI>
<LI>Problem Detection: identifying flexibility and quality problems</LI>
<LI>Problem Resolution: selecting new software architectures to correct the problems</LI>
<LI>Reorganisation: transforming the existing software architecture for a new release</LI>
<LI>Change Propagation: ensuring that all client systems benefit from the new release</LI></OL>

<P><IMG SRC="Image154.gif" WIDTH=444 HEIGHT=191></P>
<B><P><A NAME="_Ref408981443"><A NAME="_Ref410538773"><A NAME="_Toc415978431">Figure 1</A>: FAMOOS re-engineering life cycle</A></A></P>
</B><P>To realise that life cycle, three research areas which are likely to furnish solutions have been selected for further investigation</P><DIR>

<DL>
<DT>Metrics &amp; Heuristics [DETECTM]</DT>
<DD>Applied in phase (2) to identify problems and phase (3) to measure improvement.</DD>
<DT>Grouping [DOCUM]</DT>
<DD>Applied in phase (1) to form software modules and phase (3) to form target architectures.</DD>
<DT>Reorganisation Operations [REORGOP]</DT>
<DD>Applied in phase (4) to perform the actual program transformations and phase (5) to adapt the target software context.</DD>
</DL></DIR>

<P>Currently, the FAMOOS partners are building a number of tool prototypes for conducting various experiments within those three research areas. However, the source code available for case studies is written in different implementation languages (C++, Ada and to a lesser extent Java and Smalltalk). To avoid equipping all the tool prototypes with parsing technology for all of the implementation languages, it is necessary to agree on a common information exchange format with language specific extensions (see Figure 2). This document is a specification for such a format.</P>
<P><IMG SRC="Image155.gif" WIDTH=387 HEIGHT=162></P>
<B><P><A NAME="_Ref410188662"><A NAME="_Toc415978432">Figure 2</A>: Conception of the Common Exchange Format</A></P>
</B><H2><A NAME="_Ref410210475"><A NAME="_Toc415978395">2) Requirements Specification</A></A></H2>
<P>Based on our experiences with the tool prototypes built so far, plus given a survey of the literature on re-engineering repositories and code base management systems we specified the following requirement list. The list is split up in two, one part defining requirements concerning the data model, the other part specifying issues concerning the representation.</P><DIR>

<EM><DL>
<DT>Data Model</DT></DIR>

<OL>

<OL>

<DD><LI>Extensible.</EM><BR>
To handle the definition of language plug-ins, the data model must allow extensions with language specific entities and properties. Some tool prototypes may also need to define tool specific properties.</LI></DD>
<EM><DD><LI>Sufficient basis for metrics, heuristics, grouping and re-engineering operations.</EM><BR>
To avoid a common denominator that would ineffective for our goals, we set the lower limit for the model to everything that is required to experiment with the tool prototypes.</LI></DD>
<EM><DD><LI>Readily distillable from source code.</EM><BR>
Since it is not our aim to define a model that covers all aspects of all languages, we set the upper limit for the model as something that can be generated by ordinary code parsers.</LI></DD></OL>
</OL>
<DIR>

<EM><DT>Representation</DT></DIR>

<OL>

<OL>

<DD><LI>Easy to generate by available parsing technology.</EM><BR>
Since we cannot wait for future developments, we must use parsers available today keeping an eye on short-term evolution. Within the FAMOOS project, parsing technology comes mainly from the FAST library part of the Audit platform. However, there are a number of other viable alternatives: like the SNiFF+ symbol table which is accessible via an API; like Ada compilers which provide standard API's for accessing internal data structures; like the tables generated by Audit which can be transformed in what is needed; like the Java inspection facilities part of Java.lang.reflect or even the Java byte code itself; like Smalltalk inspection facilities and parsers that are part of every Smalltalk implementation.</LI></DD>
<EM><DD><LI>Simple to process.</EM><BR>
As the exchange format will be fed into a wide variety of tool prototypes, the format itself should be quite easy to convert into the internal data structures of those prototypes. On top of that, processing by "standard" file utilities (i.e., grep, sed) and scripting languages (i.e., perl, python) must be easy since they may be necessary to cope with format mismatches.</LI></DD>
<EM><DD><LI>Convenient for querying.</EM><BR>
A large portion of re-engineering is devoted to the search for information. The representation should be chosen so that it may easily be transformed into an input-stream for querying tools (i.e., spreadsheets and databases).</LI></DD>
<EM><DD><LI>Human readable.</EM><BR>
The exchange format will be employed by (buggy) prototypes. To ease debugging, the format itself should be readable by humans. Especially, references between entities should be by name rather than by identifiers bearing no semantics.</LI></DD>
<EM><DD><LI>Allows combination with information from other sources.</EM><BR>
Although most of the data model will be extracted from source code, we expect that other origins can provide input as well. Especially CASE tools with design diagrams (e.g., TDE or Rational/Rose) are likely candidates. Thus, the representation should allow merging information from other origins.</LI></DD>
<EM><DD><LI>Supports industry standards.</EM><BR>
Since the tool prototypes must be utilised within an industry context, they must integrate with whatever tools already in use. Ad hoc exchange formats (even when they can be translated with scripts) hinder such integration, and --when available-- the representation should favour an industry standard.</LI></DD>
</DL></OL>
</OL>

<H2><A NAME="_Toc415978396">3) CDIF Transfer Format</A></H2>
<P>We have chosen CDIF as the basis for the FAMOOS exchange model [EVALCDIF]. CDIF is an industrial standard for transferring models created with different tools. More information concerning the CDIF standard can be found at <A HREF="http://www.cdif.org/">http://www.cdif.org/</A>. Among others, the CDIF standard provides an encoding that allows the transfer models via flat ASCII streams.</P>
<H2><A NAME="_Toc415978397">4) The Data Model</A></H2>
<H3><A NAME="_Toc415978398">4.1. The Core Model</A></H3>
<P>The core model specifies the entities and relations that can and should be extracted immediately from source code. We explicitly opted for longer names here ("<CODE>ClassDefinition</CODE>" instead of "<CODE>Class</CODE>", "<CODE>MethodDefinition</CODE>" instead of "<CODE>Method</CODE>") because other sources (CASE tools, architecture extractors, etc.) may also provide a "<CODE>Method</CODE>" and a "<CODE>Class</CODE>", which is not necessarily the same concept as a method or a class extracted from source code. The long naming scheme should allow us to deal with other information sources.</P>
<P><IMG SRC="Image156.gif" WIDTH=492 HEIGHT=279></P>
<B><P><A NAME="_Toc415978433">Figure 3: The Core Model</A></P>
</B><H3><A NAME="_Toc415978399">4.2. Level of Reification</A></H3>
<P>The core model contains entities that not all parsers may provide (for instance, the <CODE>MethodInvocation</CODE> and <CODE>VariableAccess</CODE> associations are not available from the SNiFF-API). Also, some tools do not always need all of this information (i.e. many metrics can already be gathered from <CODE>ClassDefinition</CODE>, <CODE>MethodDefinition</CODE> alone). To allow "incomplete" models, we introduced the <EM>level of reification</EM>.</P>
<P>Basically, the level of reification is an integer, telling how much of the core model is actually available. In principle, the bigger the number, the more information is available. The following table gives an overview of the levels of reification.</P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=595>
<TR><TD WIDTH="13%" VALIGN="TOP">
<P>Level 1</TD>
<TD WIDTH="87%" VALIGN="TOP">
<CODE><P>ClassDefinition, InheritanceDefinition, MethodDefinition</CODE>.</P>
<P>Level 1 is the minimum model that parsers should be able to provide and corresponds with what is usually understood as the interface of a class.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<P>Level 2</TD>
<TD WIDTH="87%" VALIGN="TOP">
<CODE><P>Level 1 + AttributeDefinition</CODE></TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<P>Level 3</TD>
<TD WIDTH="87%" VALIGN="TOP">
<CODE><P>Level 2 + VariableAccess</CODE></TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<P>Level 4</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P>Level 3 + <CODE>MethodInvocation</CODE>. The <CODE>candidateMethod</CODE> role for <CODE>MethodInvocation</CODE> is empty; i.e. it is not necessary to compute the actual class that defines the invoked method.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<P>Level 5</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P>Level 4 + the <CODE>candidateMethod</CODE> role. This implies that parsers should provide some details about the types of the arguments that are passed when invoking the method.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP">
<P>Level 6</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P>Level 5 + all information concerning arguments, local variables, global variables, implicit variables.</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc415978449"><A NAME="_Ref415979631"><A NAME="_Ref415979649">Table 1</A>: Levels of Reification</A></A></P>
</B><H3><A NAME="_Toc415978400">4.3. Entity / Association (the Meta-Meta Model)</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=649>
<TR><TD WIDTH="48%" VALIGN="TOP">
<B><P ALIGN="CENTER"><A NAME="_Toc410624943">&lt;&lt;metaclass&gt;&gt;<BR>
Association</B></TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="47%" VALIGN="TOP">
<B><P ALIGN="CENTER">&lt;&lt;metaclass&gt;&gt;<BR>
Entity</B></TD>
</TR>
<TR><TD WIDTH="48%" VALIGN="TOP">
<P>kind (): Name<BR>
sourceAnchor (): Qualifier<BR>
commentLineAt: (pos Integer): String<BR>
propertyAt (key Name): Object</TD>
<TD WIDTH="6%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="47%" VALIGN="TOP">
<P>kind (): Name<BR>
sourceAnchor (): Qualifier<BR>
commentLineAt: (pos Integer): String<BR>
propertyAt (key Name): String</P>
<P>name (): Name<BR>
uniqueName (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc415978434">Figure 4: The Meta-Meta Model</A> (Entity, Association)</A></P>
</B><P>Entity and Association are explicit parts of the meta-meta model made available to handle the extensibility requirement (see "<B>2) Requirements</B> Specification" - p.<A HREF="#_Ref410210475">*</A>). For specifying language plug-ins, it is allowed to define language specific entities and associations plus it is allowed to add language specific properties to existing entities or relations. Tool prototypes are more restricted in extensions to the model: they can define tool specific properties for existing entities or associations, but can not extend the repertoire of entities and associations themselves.</P>
<P>Users who do not need to extend the model may safely assume that the meta-classes <CODE>Association</CODE> and <CODE>Entity</CODE> behave like an abstract superclass for the classes in the core model. That is, if a class in the core model is said to be an <CODE>Association</CODE> or an <CODE>Entity</CODE> (via a stereotype on the class), it will inherit the protocol from those classes.</P>

<UL>
<CODE><LI>kind: Name; mandatory</CODE><BR>
Is a name that identifies the class (type) of an object.</LI>
<CODE><LI>sourceAnchor: Qualifier; optional, default = 'null'</CODE><BR>
Is a qualifier that identifies the location in the source where the information is extracted.<BR>
The exact format of the qualifier is dependent on the source of the information. Usually, it will be an anchor in a source file, in which case the following format should be used<BR>
&#9;<CODE>(file &lt;filespec&gt; start &lt;start_index&gt; stop &lt;stop_index&gt;)</CODE>.<BR>
Where &lt;<CODE>filespec</CODE>&gt; is a string holding the name of the source-file in an operating system dependent format (preferably a filename relative to some project directory). Where &lt;<CODE>start_index</CODE>&gt; and &lt;<CODE>stop_index</CODE>&gt; are indices starting at 1 and holding the beginning&nbsp;/ ending character position in the source file.<BR>
Extra position indices may be added to handle anchors in files that have been edited after parsing. For instance, the line &amp; column of the character (<CODE>startline</CODE>, <CODE>startcol</CODE>, <CODE>stopline</CODE>, <CODE>stopcol</CODE>). Or the negative offset counting from the end of the file instead of from the beginning (<CODE>negstart</CODE>, <CODE>negstop</CODE>).</LI>
<CODE><LI>commentLines: 0..N String</CODE><BR>
Entities and associations may own a number of comment lines, where tools can store textual information about the object. One particular comment line is accessed via its position.</LI>
<CODE><LI>properties: 0..N Object</CODE><BR>
Entities and associations may own a number of properties where extensions of the core model may be stored. One particular property is accessed via its name.</LI></UL>

<P>To enable a global referencing scheme based on names, the key classes in the model should respect the minimal interface of <CODE>Entity</CODE>.</P>

<UL>
<CODE><LI>name: String; mandatory</CODE><BR>
Is a string that provides some human readable reference to an entity.</LI>
<CODE><LI>uniqueName: String; mandatory</CODE><BR>
Is a string that is computed based on the name of the entity. Each class must define its specific formula. The uniqueName serves as an external reference to that entity and must be unique for all entities in the model.</LI></UL>

<H3><A NAME="_Toc415978401">4.4. Basic Data Types</A></H3>
<P>Besides the usual primitive data types (String, Integer, Boolean) there are a number of extra data types that are considered "basic". Note that all data types have the possibility of representing a null-value.</P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=548>
<TR><TD WIDTH="31%" VALIGN="TOP">
<B><P ALIGN="CENTER">Name</B></TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<B><P ALIGN="CENTER">Qualifier</B></TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<B><P ALIGN="CENTER">Index</B></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<P>name: String</TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>qualifier: String</TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>index: Integer</TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<P>isNull (): Boolean<BR>
notNull (): Boolean</TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>isNull (): Boolean<BR>
notNull (): Boolean</TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>isNull (): Boolean<BR>
notNull (): Boolean</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624944"><A NAME="_Toc415978435">Figure 5: Basic Data Types (Name, Qualifier </A>and Index)</A></P>

<UL>
</B><CODE><LI>Name</CODE> vs. <CODE>Qualifier</CODE><BR>
A <CODE>Name</CODE> is a string that bears semantics inside the model, while a <CODE>Qualifier</CODE> is a string that gets its semantics from outside the model. A <CODE>String</CODE> does not bear any semantics. For instance, a <CODE>uniqueName</CODE> may be used to refer to another object, hence bears semantics inside the model. However, a <CODE>sourceAnchor</CODE> will store some information that must be interpreted by applications outside the model, hence is a qualifier. Finally, a comment line is a string, since it does not bear any semantics understandable by a computer.</LI>
<CODE><LI>Index</CODE><BR>
An Index represents a position in some sequence. Indices always have a base of 1, leaving 0 as the null value.</LI></UL>

<H3><A NAME="_Toc415978402">4.5. Core Entity: ClassDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Entity&gt;&gt;<BR>
<B>ClassDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>isAbstract (): BooleanOrNull<BR>
scopeQualifier (): Qualifier</TD>
</TR>
</TABLE>

<B><P><A NAME="_Ref410484365"><A NAME="_Toc410624945"><A NAME="_Toc415978436">Figure 6: ClassDefinition</A></A></A></P>
</B><P>A <CODE>ClassDefinition</CODE> represents the definition of a class in source code. What exactly constitutes such a definition is a language dependent issue. Besides the attributes inherited from the meta-class Entity, it has the following attributes:</P>

<UL>
<CODE><LI>isAbstract: Boolean; optional, default = 'null'</CODE><BR>
Is a predicate telling whether the class is declared abstract. Abstract classes are important in OO modelling, but how they are recognised in source code is a language dependent issue.</LI>
<CODE><LI>scopeQualifier: Qualifier; optional, default = 'null'</CODE><BR>
Is a string with a language dependent interpretation, that defines the scope of a class. A null scopeQualifier is allowed, it means that the class has global scope. The scopeQualifier concatenated with the name of the class must provide a unique name for that class within the model.</LI>
<LI>formula for <CODE>uniqueName</LI></UL>

</CODE><PRE>&#9;if isNull (scopeQualifier(class)) then<BR>
&#9;  uniqueName (class) = name (class)<BR>
&#9;else<BR>
&#9;  uniqueName (class) = scopeQualifier (class)<BR>
&#9;    + "::" + name (class)</PRE>
<H3><A NAME="_Toc415978403">4.6. Core Entity: MethodDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Entity&gt;&gt;<BR>
<B>MethodDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToClass (): Name<BR>
accessControlQualifier (): Qualifier<BR>
hasClassScope (): BooleanOrNull<BR>
signature (): Qualifier<BR>
isAbstract (): BooleanOrNull<BR>
isConstructor (): BooleanOrNull<BR>
isAccessor (): BooleanOrNull<BR>
declaredReturnType (): Qualifier</TD>
</TR>
</TABLE>

<B><P><A NAME="_Ref410538730"><A NAME="_Toc410624946"><A NAME="_Toc415978437">Figure 7: MethodDefinition</A></A></A></P>
</B><P>A <CODE>MethodDefinition</CODE> represents the definition in source code of an aspect of the behaviour of a class. What exactly constitutes such a definition is a language dependent issue. Besides the attributes inherited from the meta-class Entity, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToClass: Name; mandatory</CODE><BR>
Is a name referring to the class owning the method. It uses the uniqueName of the class as a reference.</LI>
<CODE><LI>accessControlQualifier: Qualifier; optional, default = 'null'</CODE><BR>
Is a string with a language dependent interpretation, that defines who is allowed to invoke it (for instance, 'public', 'private').</LI>
<CODE><LI>hasClassScope: Boolean; optional, default = 'false'</CODE><BR>
Is a predicate telling whether the method has class scope (i.e., invoked on the class) or instance scope (i.e., invoked on an instance of that class).</LI>
<CODE><LI>signature (): Qualifier; mandatory</CODE><BR>
Is a string that allows to uniquely distinguish a method within a class. This is necessary because there exist OO languages (i.e., C++, Java) that allow to overload methods, so that the same method name may be associated with different parameter lists, each with its own method body. Also, sometimes it is possible to define the same method name once on the instance level and once on the class level.<BR>
The way the signature string is composed is language dependent, but it should at least include the name of the method.</LI>
<CODE><LI>isAbstract: Boolean; optional, default = 'null'</CODE><BR>
Is a predicate telling whether the method is declared abstract. Abstract methods are important in OO modelling, but how they are recognised in source code is a language dependent issue.</LI>
<CODE><LI>isConstructor: Boolean; optional, default = 'null'</CODE><BR>
Is a predicate telling whether the method is a constructor. A constructor is a method that creates an (initialised) instance of the class it is defined on. Thus a method that creates an instance of another class is not considered a constructor. How constructor methods are recognised in source code is a language dependent issue.</LI>
<CODE><LI>isAccessor: Boolean; optional, default = 'null'</CODE><BR>
Is a predicate telling whether the method is an accessor. There are two kinds of accessors, a reader accessor and a writer accessor. A reader-accessor is a method with one receiver parameter, returning the value of an attribute of the class the method is defined on. A writer method is a method with one receiver parameter and one value parameter, storing the value inside the attribute of a class. How accessor methods are recognised in source code is a language dependent issue.</LI>
<CODE><LI>declaredReturnType: Qualifier; optional, default = 'null'</CODE><BR>
Is a qualifier that via interpretation outside the model refers to the class of the returned object.<BR>
Note that we need a language dependent interpretation to link a typename to a class name, because in most OO languages, types are not always equivalent to a class. How the declaredReturnType may be recognised in source code and how the return type matches to a class are language dependent issue</LI>
<LI>formula for <CODE>uniqueName</LI></UL>

</CODE><PRE>&#9;uniqueName (method) = belongsToClass (method) +<BR>
&#9;  "::" + signature (method)</PRE>
<H3><A NAME="_Toc415978404">4.7. Core Entity: AttributeDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Entity&gt;&gt;<BR>
<B>AttributeDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToClass (): Name<BR>
accessControlQualifier (): Qualifier<BR>
hasClassScope (): BooleanOrNull</P>
<P>declaredType (): Qualifier<BR>
interfaceSignatureAt (pos Integer): Qualifier</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624947"><A NAME="_Toc415978438">Figure 8: AttributeDefinition</A></A></P>
</B><P>An <CODE>AttributeDefinition</CODE> represents the definition in source code of an aspect of the state of a class. What exactly constitutes such a definition is a language dependent issue. Besides the attributes inherited from the meta-class Entity, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToClass: Name; mandatory</CODE><BR>
Is a name referring to the class owning the attribute. It uses the uniqueName of the class as a reference.</LI>
<CODE><LI>accessControlQualifier: Qualifier; optional, default = 'null'</CODE><BR>
Is a string with a language dependent interpretation, that defines who is allowed to access it (for instance, 'public', 'private').</LI>
<CODE><LI>hasClassScope: Boolean; optional, default = 'false'</CODE><BR>
Is a predicate telling whether the attribute has class scope (i.e., shared memory location for all instances of the class) or instance scope (i.e., separate memory location for each instance of the class).</LI>
<CODE><LI>declaredType: Qualifier; optional, default = 'null'</CODE><BR>
See definition of VariableDefinition (see p.<A HREF="#_Ref410622212">*</A>).</LI>
<CODE><LI>interfaceSignatures: 0 .. N Qualifier</CODE><BR>
See definition of VariableDefinition </LI>
<LI>formula for <CODE>uniqueName</LI></UL>

</CODE><PRE>&#9;uniqueName (attribute) = belongsToClass (attribute) +<BR>
&#9;  "." + name (attribute)</PRE>
<H3><A NAME="_Toc415978405">4.8. Core Association: InheritanceDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Association&gt;&gt;<BR>
<B>InheritanceDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>subclass (): Name<BR>
superclass (): Name<BR>
accessControlQualifier (): Qualifier<BR>
index (): Index</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624948"><A NAME="_Toc415978439">Figure 9: InheritanceDefinition</A></A></P>
</B><P>An <CODE>InheritanceDefinition</CODE> represents the definition in source code of an inheritance association between two classes. One class then plays the role of the superclass, the other plays the role of the subclass. What exactly constitutes such a definition is a language dependent issue. Besides the attributes inherited from the meta-class Association, it has the following attributes:</P>

<UL>
<CODE><LI>subclass: Name; mandatory</CODE><BR>
Is a name referring to the class that inherits. It uses the uniqueName of the class as a reference.</LI>
<CODE><LI>superclass: Name; mandatory</CODE><BR>
Is a name referring to the class that is inherited from. It uses the uniqueName of the class as a reference.</LI>
<CODE><LI>accessControlQualifier: Qualifier; optional, default = 'null'</CODE><BR>
Is a string with a language dependent interpretation, that defines how subclasses access their superclasses (for instance, 'public', 'private').</LI>
<CODE><LI>index: Index; optional, default = 'null'</CODE><BR>
In languages with multiple inheritance, this is the position of the superclass in the list of superclasses of one subclass. Usually this will have a null value, but it may be necessary for OO languages with multiple inheritance that resolve name collisions via the order of the superclasses (i.e., CLOS).</LI></UL>

<H3><A NAME="_Toc415978406">4.9. Core Association: VariableAccess</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Association&gt;&gt;<B><BR>
VariableAccess</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>accessesVariable (): Name<BR>
accessedInMethod (): Name<BR>
isAccessLValue (): BooleanOrNull <BR>
isArgument (): Boolean</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624949"><A NAME="_Toc415978440">Figure 10: VariableAccess</A></A></P>
</B><P>A <CODE>VariableAccess</CODE> represents the definition in source code of a method accessing a variable. Depending on the level of reification (see Table 1, p. <A HREF="#_Ref415979649">*</A>), that variable may be an attribute, a local variable, an argument, a global variable. What exactly constitutes such a definition is a language dependent issue. Besides the attributes inherited from the meta-class Association, it has the following attributes:</P>

<UL>
<CODE><LI>accessesVariable: Name; mandatory</CODE><BR>
Is a name referring to the variable being accessed. It uses the uniqueName of the variable as a reference.</LI>
<CODE><LI>accessedInMethod: Name; mandatory</CODE><BR>
Is a name referring to the method doing the access. It uses the uniqueName of the variable as a reference.</LI>
<CODE><LI>isAccessLValue: Boolean; optional, default = 'null'</CODE><BR>
Is a predicate telling whether the value was accessed as Lvalue, i.e. a location value or a value on the left side of an assignment. When the predicate is true, the memory location denoted by the variable might change it value; false means that the contents of the memory location is read; null means that it is unknown.<BR>
Note that LValue is the inverse of RValue.</LI>
<CODE><LI>isArgument: Boolean; mandatory, default = 'false'</CODE><BR>
Is a predicate telling whether the variable access is contained within an ArgumentDescriptor (see p.<A HREF="#_Ref410614674">*</A>). The default value is false and users need to concern about this predicate only when they reify argument passing on method invocations (see Table 1, p. <A HREF="#_Ref415979649">*</A>).</LI></UL>

<H3><A NAME="_Toc415978407">4.10. Core Association: MethodInvocation</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Association&gt;&gt;<BR>
<B>MethodInvocation</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>invokedByMethod (): Name<BR>
invokeMethod (): Name</P>
<P>candidateMethodsAt (pos Integer): Name<BR>
argumentsAt (pos Integer): ArgumentDescriptor</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624950"><A NAME="_Toc415978441">Figure 11: MethodInvocation</A></A></P>
</B><P>A <CODE>MethodInvocation</CODE> represents the definition in source code of a method invoking another method. What exactly constitutes such a definition is a language dependent issue. However, it is important to note that due to late binding polymorphism, a method invocation is quite different from a procedure call. Especially, it means that at parse time there exist a one-to-many relationship between the method invocation and the actual method invoked. This explains the presence of the <CODE>candidateMethods</CODE> aggregation.</P>
<P>Besides the attributes inherited from the meta-class Association, it has the following attributes:</P>

<UL>
<CODE><LI>invokedByMethod: Name; mandatory</CODE><BR>
Is a name referring to the method doing the method invocation. It uses the uniqueName of the method as a reference.</LI>
<CODE><LI>invokeMethod: Name; mandatory</CODE><BR>
Is a name holding the name of the method invoked. Due to late binding polymorphism, the name of the invoked method is not enough to assess which method is invoked. Further analysis based on the arguments is necessary.</LI>
<CODE><LI>candidateMethods: 0 .. N Name</CODE><BR>
Is a multi-valued attribute holding a number of method names. Each method name refers to a method that may be the actual method invoked at run-time. When the collection is empty, it does not mean that no candidate method exists since we assume to start from a working system, all methods invoked should exist. Rather an empty collection denotes that a parser did not perform the extra analysis to compute the candidate methods.</LI>
<CODE><LI>arguments: 0 .. N ArgumentDescriptor</CODE><BR>
Is a multi-valued attribute holding a number of argument descriptors. Each argument descriptor gives more information about an argument being passed. When the collection is empty it does not mean that no arguments are passed since each method invocation involves at least has one receiver there is always one argument, otherwise it is just a procedure call. Rather, an empty collection denotes that a parser did not extract information about the arguments.</LI></UL>

<H3><A NAME="_Toc415978408">4.11. ArgumentDescriptor</A>, ComplexExpression &amp;  SimpleVariableAccess</H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=548>
<TR><TD WIDTH="26%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=3>
<P ALIGN="CENTER">&lt;&lt;Association&gt;&gt;<BR>
<B>ArgumentDescriptor</B></TD>
<TD WIDTH="26%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="26%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=3>
<P>position (): Index<BR>
isReceiver (): Boolean</TD>
<TD WIDTH="26%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="26%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=3>
<P ALIGN="CENTER"><IMG SRC="Image160.gif" WIDTH=153 HEIGHT=40></TD>
<TD WIDTH="26%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="48%" VALIGN="TOP" COLSPAN=2>
<P ALIGN="CENTER">&lt;&lt;Association&gt;&gt;<BR>
<B>ComplexExpression</B></TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=2>
<P ALIGN="CENTER">&lt;&lt;Association&gt;&gt;<BR>
<B>SimpleVariableAccess</B></TD>
</TR>
<TR><TD WIDTH="48%" VALIGN="TOP" COLSPAN=2>&nbsp;</TD>
<TD WIDTH="3%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=2>
<P>variableAccess (): VariableAccess</TD>
</TR>
</TABLE>

<B><P><A NAME="_Ref410614674"><A NAME="_Toc410624951"><A NAME="_Toc415978442">Figure 12: ArgumentDescriptor, ComplexExpression &amp; SimpleVariableAccess</A></A></A></P>
</B><P>An <CODE>ArgumentDescriptor</CODE> represents the passing of an argument when invoking a method. What exactly constitutes such a definition is a language dependent issue. The model distinguishes between two kind of arguments, a complex expression or a simple variable access. The former means that some expression is passed, in that case the contents of the expression is not further specified. The latter means that some variable is passed, in which case a variable access is maintained.</P>
<P>Besides the attributes inherited from the meta-class Association, it has the following attributes:</P>

<UL>
<CODE><LI>position: Index; mandatory</CODE><BR>
The position of the argument in the list of arguments.</LI>
<CODE><LI>isReceiver: Boolean; mandatory</CODE><BR>
Is a predicate telling wether this argument plays the role of the receiever in the containing method invocation.</LI>
<LI><A NAME="_Toc415978409"><CODE>variableAccess: VariableAccess; mandatory</CODE><BR>
Holds an instance of variable access.</LI></UL>

<H3>4.12. VariableDefinition</A> Hierarchy</H3>
<P><IMG SRC="Image161.gif" WIDTH=464 HEIGHT=347></P>
<B><P><A NAME="_Ref410622212"><A NAME="_Toc415978443">Figure 13: VariableDefinition Hierarchy</A></A></P>
</B><P>All possible variable definitions are subclasses of the class VariableDefinition. VariableDefinition itself participates in the VariableAccess association.</P>
<H3><A NAME="_Toc415978410">4.13. VariableDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Entity&gt;&gt;<BR>
<B>VariableDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>declaredType (): Qualifier<BR>
interfaceSignatureAt (pos Integer): Qualifier</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624953"><A NAME="_Toc415978444">Figure 14: VariableDefinition</A></A></P>
</B><P>A <CODE>VariableDefinition</CODE> represents the definition in source code of a variable, i.e. a named memory location. Subclasses of this class represent different mechanisms for defining such a variable. Besides the attributes inherited from the meta-class Entity, it has the following attributes:</P>

<UL>
<CODE><LI>declaredType: Qualifier; optional, default = 'null'</CODE><BR>
Is a qualifier that via interpretation outside the model refers to the class of the returned object.<BR>
Note that we need a language dependent interpretation to link a typename to a class name, because in most OO languages, types are not always equivalent to a class. How the declaredType may be recognised in source code and how the type matches to a class are language dependent issue.</LI>
<CODE><LI>interfaceSignatures: 0 .. N Qualifier</CODE><BR>
Is a multi-valued attribute holding a number of method signatures. Each method signature tells that this method is actually invoked with that variable playing the role of a receiver. This should allow to compare the public interface of the declared type with the interface that is really used from the outside.<BR>
A parser may decide not to extract information about the method signatures, in that case the collection is empty. However, an empty collection may also imply that no methods are invoked on that variable.</LI></UL>

<H3><A NAME="_Toc415978411">4.14. GlobalVariableDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Entity&gt;&gt;<BR>
<B>GlobalVariableDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>scopeQualifier (): Qualifier</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624954"><A NAME="_Toc415978445">Figure 15: GlobalVariableDefinition</A></A></P>
</B><P>A <CODE>GlobalVariableDefinition</CODE> represents the definition in source code of a variable with a lifetime equal to the lifetime of a running system, and which is globally accessible. What exactly constitutes such a definition is a language dependent issue. Besides the attributes inherited from the meta-class Entity and the class Variable, it has the following attributes:</P>

<UL>
<CODE><LI>scopeQualifier: Qualifier; optional, default = 'null'</CODE><BR>
Is a string with a language dependent interpretation, that defines a possible scope of the variable. A null scopeQualifier is allowed, it means that the variable must not be explicitly imported before using it. The scopeQualifier concatenated with the name of the variable must provide a unique name for that variable within the model.</LI>
<LI>formula for <CODE>uniqueName</LI></UL>

</CODE><PRE>&#9;if isNull (scopeQualifier(globalVariable)) then<BR>
&#9;  uniqueName (globalVariable) = name (globalVariable)<BR>
&#9;else<BR>
&#9;  uniqueName (globalVariable) = scopeQualifier (globalVariable)<BR>
&#9;    + "." + name (globalVariable)</PRE>
<H3><A NAME="_Toc415978412">4.15. ImplicitVariableDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Entity&gt;&gt;<BR>
<B>ImplicitVariableDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>scopeQualifier (): Qualifier</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624955"><A NAME="_Toc415978446">Figure 16: ImplicitVariableDefinition</A></A></P>
</B><P>An <CODE>ImplicitVariableDefinition</CODE> represents the definition in source code of context dependent reference to a memory location (i.e., 'this' in C++ and Java, 'self' and 'super' in Smalltalk). What exactly constitutes such a definition is a language dependent issue. Besides the attributes inherited from the meta-class Entity and the class Variable, it has the following attributes:</P>

<UL>
<CODE><LI>scopeQualifier: Qualifier; optional, default = 'null'</CODE><BR>
Is a string with a language dependent interpretation, that defines a possible scope of the variable. A null scopeQualifier is allowed, it means that the variable has universal scope. The scopeQualifier concatenated with the name of the variable must provide a unique name for that variable within the model.</LI>
<LI>formula for <CODE>uniqueName</LI></UL>

</CODE><PRE>&#9;if isNull (scopeQualifier(implicitVariable)) then<BR>
&#9;  uniqueName (implicitVariable) = name (implicitVariable)<BR>
&#9;else<BR>
&#9;  uniqueName (implicitVariable) = <BR>
&#9;    scopeQualifier (implicitVariable)<BR>
&#9;      + "." + name (implicitVariable)</PRE>
<H3><A NAME="_Toc415978413">4.16. LocalVariableDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Entity&gt;&gt;<BR>
<B>LocalVariableDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToMethod (): Name</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624956"><A NAME="_Toc415978447">Figure 17: LocalVariableDefinition</A></A></P>
</B><P>A <CODE>LocalVariableDefinition</CODE> represents the definition in source code of a variable defined locally to a method. What exactly constitutes such a definition is a language dependent issue. Besides the attributes inherited from the meta-class Entity and the class Variable, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToMethod: Name; mandatory</CODE><BR>
Is a name referring to the method owning the variable. It uses the uniqueName of the method as a reference.</LI>
<LI>formula for <CODE>uniqueName</LI></UL>

</CODE><PRE>&#9;uniqueName (localVar) = belongsToMethod (localVar) +<BR>
&#9;  "." + name (localVar)</PRE>
<H3><A NAME="_Toc415978414">4.17. FormalParameterDefinition</A></H3>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=378>
<TR><TD VALIGN="TOP">
<P ALIGN="CENTER">&lt;&lt;Entity&gt;&gt;<BR>
<B>FormalParameterDefinition</B></TD>
</TR>
<TR><TD VALIGN="TOP">
<P>belongsToMethod (): Name<BR>
position (): Index<BR>
isReciever (): Boolean</TD>
</TR>
</TABLE>

<B><P><A NAME="_Toc410624957"><A NAME="_Toc415978448">Figure 18: FormalParameterDefinition</A></A></P>
</B><P>A <CODE>FormalParameterDefinition</CODE> represents the definition in source code of a formal parameter. What exactly constitutes such a definition is a language dependent issue. Besides the attributes inherited from the meta-class Entity and the class Variable, it has the following attributes:</P>

<UL>
<CODE><LI>belongsToMethod: Name</CODE><BR>
Is a name referring to the method owning the variable. It uses the uniqueName of the method as a reference.</LI>
<CODE><LI>position: Index; mandatory</CODE><BR>
The position of the parameter in the list of parameters.</LI>
<CODE><LI>isReciever: Boolean; mandatory; default = 'false'</CODE><BR>
Is a predicate telling whether the parameter plays the role of the receiver. This is required in those cases where the receiver is not passed via an implicit variable, which is quite unusual hence the default null value.</LI>
<LI>formula for <CODE>uniqueName</LI></UL>

</CODE><PRE>&#9;uniqueName (formalPar) = belongsToMethod (formalPar) +<BR>
&#9;  "." + name (formalPar)</PRE>
<H2><A NAME="_Toc415978415">5) Open Questions</A></H2>
<H3><A NAME="_Toc415978416">5.1. Why not UML?</A></H3>
<P>The unified Modelling Language (UML) [BoochEtAl'96] is rapidly becoming the standard modelling language for object-oriented software, even in industry. So, UML is a viable candidate for serving as the data model behind our exchange format. Nevertheless, UML is geared towards an analysis / design language and there exists no accurate and straightforward mapping from source-code to UML. For instance, inheritance like applied in an implementation does not necessarily correspond to generalisation like specified in UML (e.g., in an implementation a Rectangle might be a subclass of Square while a correct generalisation is the other way around). Likewise, attribute definitions do not always correspond with aggregation (e.g., is a Rectangle an aggregation of two instances of Point or is it an aggregation of four integers). Thus choosing UML would violate the requirement that the data model should be readily distillable from source code (see p.<A HREF="#_Ref410210475">*</A>) and that's the first motivation to rule out UML.</P>
<P>Moreover, extracting an accurate UML model from source code is considered quite important during the model capture phase of the re-engineering life cycle (see Figure 1). The FAMOOS project will definitely investigate that topic in further depth, and we do not want to hamper such investigations by choosing a straightforward but inaccurate mapping. That is the second motivation to rule out UML.</P>
<P>However, we relied heavily on UML in the terminology and naming conventions applied in our model to become independent of the implementation language. For example, we talk about attributes instead of members (C++) or instance variable (Smalltalk) and we talk about classes instead of types (Ada).</P>
<H3><A NAME="_Toc415978417">5.2. Why not CORBA/IDL?</A></H3>
<P>Corba is receiving widespread attention as interoperability standard between different object-oriented implementation languages. The IDL (interface description language) is used to specify the external interface of a software component and there are tools that extract IDL from source code. As such, Corba/IDL is a viable candidate to serve as our exchange format.</P>
<P>However, Corba/IDL only describes the interface of a software component, not the internal dependencies like method invocations and variable accesses. Those dependencies are necessary in the problem detection and reorganisation phases of the re-engineering life cycle (Figure 1). Thus, choosing Corba/IDL would violate the requirement of being a sufficient basis for re-engineering operations (see p.<A HREF="#_Ref410210475">*</A>).</P>
<H3><A NAME="_Toc415978418">5.3. What about Dynamic Information?</A></H3>
<P>Because of late binding polymorphism, not all method invocations can be resolved at compile time. Also, a model based on source code is not ideal for identifying sequences of interactions between objects. Thus, basing the model solely on static information eliminates some interesting facts about a software system and one might consider including run-time information as well.</P>
<P>For the moment we consider the issue too premature to include in an information exchange standard. The technology is available (i.e., Look for C++, method wrappers for Smalltalk) but is certainly not part of the standard tool repertoire. And extracting run-time information generates such a wealth of data that we cannot asses what is important enough to maintain.</P>
<H3><A NAME="_Toc415978419">5.4. How do you handle hybrid languages (C++, Ada...)?</A></H3>
<P>Some OO languages are extensions of older procedural languages, and as such allow a hybrid programming style. Part of the object-oriented re-engineering problem is precisely that programmers did not use object-oriented constructs where it would have been advantageous. For problem detection, it might be worthwhile to include procedural constructs in the model.</P>
<P>For the moment we decided to ignore the issue. We have some ideas on expressing procedural programming constructs as degenerated object-oriented constructs (e.g., define a procedure as a method defined on a dummy class) but no concrete proposal in that direction.</P>
<H2><A NAME="_Toc415978420">6) References</A></H2>
<H3><A NAME="_Toc415978421">6.1. FAMOOS Internal References</A></H3>
<P>[<A NAME="DETECTM">DETECTM</A>]&#9;FAMOOS Achievement Report DETECTM-A.2.3.2. " Specification of Techniques and Strategies for Problem Detection". Benedikt Schulz, Forschungszentrum Informatik.</P>
<P>[<A NAME="DOCUM">DOCUM</A>]&#9;FAMOOS Achievement Report DOCUM-A.2.3.1. " Documentation and Model Capture Method(Grouping)". Oliver Ciupke, Forschungszentrum Informatik.</P>
<P><A NAME="EVALCDIF">[EVALCDIF]</A>&#9;FAMOOS Achievement Report EVALCDIF "Evaluation of the CDIF Transfer-Format". Thomas Kohler, Daimler-Benz AG.</P>
<P>[<A NAME="REORGOP">REORGOP</A>]&#9;FAMOOS Achievement Report REORGOP-A.2.3.3./A.2.3.4. " Specification of Complex Re-engineering Operations and Target Structures ". Joachim Weisbrod, Forschungszentrum Informatik.</P>
<H3><A NAME="_Toc415978422">6.2. External References</A></H3>
<P>[<A NAME="UML96">BoochEtAl'96</A>]&#9;Booch, G., Jacobson, I. and Rumbaugh, J, The Unified Modelling Language for Object-Oriented Development. See <A HREF="http://www.rational.com/">http://www.rational.com/</A>.</P>
<OL>

<FONT FACE="Arial" SIZE=4><H1 ALIGN="CENTER"><LI><A NAME="_Toc415978423"></FONT><FONT FACE="Arial" SIZE=5>Cover Pages</A></LI></H1></OL>

</FONT><B><FONT FACE="Arial" SIZE=4><P ALIGN="CENTER">Achievement A2.4.1</P>
</B></FONT><P ALIGN="CENTER"><B><FONT FACE="Arial" SIZE=5>Definition of a Common Exchange Model</P>
</B></FONT><H2><A NAME="_Toc415978424">1) </A>Identification</H2>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=590>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Project Id:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>Esprit IV #21975 &quot;FAMOOS&quot;</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Deliverable Id:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>D 2.2  FINALFHB Final FAMOOS Methodology Handbook</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Date for delivery:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>31.03.98</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Planned date for delivery:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>31.03.98</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>WP(s) contributing to:</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>2</TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<STRONG><P>Author(s):</STRONG></TD>
<TD WIDTH="65%" VALIGN="TOP">
<P>S. Demeyer, S. Ducasse, T. Richner, M. Rieger, P. Steyaert, S. Tichelaar</TD>
</TR>
</TABLE>

<H2>2) Abstract</H2>
<P>This document defines the exchange model for usage by tool prototypes within the FAMOOS re-engineering project. The model is based upon the CDIF standard so that it can be transferred via flat ASCII streams.
<P>&nbsp;</P></P>
<H2>3) Keywords</H2>
<P>Object-oriented, reengineering, reverse engineering, code repository, FAMOOS.</P>
<H2>4) Version History</H2>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=590>
<TR><TD WIDTH="11%" VALIGN="TOP">
<STRONG><P>Ver</STRONG></TD>
<TD WIDTH="14%" VALIGN="TOP">
<STRONG><P>Date</STRONG></TD>
<TD WIDTH="24%" VALIGN="TOP">
<STRONG><P>Editor(s)</STRONG></TD>
<TD WIDTH="51%" VALIGN="TOP">
<STRONG><P>Status &amp; Notes</STRONG></TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP">
<P>0.4</TD>
<TD WIDTH="14%" VALIGN="TOP">
<P>17.11.97</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Demeyer; P. Steyaert</TD>
<TD WIDTH="51%" VALIGN="TOP">
<P>First draft version. Released to all the participants of the Ulm-workshop (21.11.97).</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP">
<P>0.5</TD>
<TD WIDTH="14%" VALIGN="TOP">
<P>24.11.97</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Demeyer</TD>
<TD WIDTH="51%" VALIGN="TOP">
<P>Quick tour of revised model; incorporates feedback generated during workshops at FZI (20.11.97) and Daimler-Benz (21.11.97).</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP">
<P>0.6</TD>
<TD WIDTH="14%" VALIGN="TOP">
<P>09.01.98</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Demeyer</TD>
<TD WIDTH="51%" VALIGN="TOP">
<P>Expanded quick tour into a full specification. Changed original document template for convenient generation of HTML.</P>
<P>Document is now ready for reviewing and defining language plug-ins.</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP">
<P>1.0</TD>
<TD WIDTH="14%" VALIGN="TOP">
<P>30.03.98</TD>
<TD WIDTH="24%" VALIGN="TOP">
<P>S. Demeyer&#9;</TD>
<TD WIDTH="51%" VALIGN="TOP">
<P>Final release:</P>

<UL>
<LI>Incorporated feedback given on prior release.</LI>
<LI>Adapted meta-model to be streamlined with CDIF; removed examples, we first need some tool experience with CDIF.</LI>
<LI>Introduced the notion of &quot;level of reification&quot;.</UL>
</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="14%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="24%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="51%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>

<H2><A NAME="_Toc415978428">7) </A>Table of Contents</H2>
<B><FONT FACE="Times"><P>Definition of a Common Exchange Model&#9;</B></FONT><A HREF="#_Toc415978392">*</A><DIR>
<DIR>

<FONT FACE="Times"><P>Abstract&#9;</FONT><A HREF="#_Toc415978393">*</A></P>
<FONT FACE="Times"><P>1) Introduction&#9;</FONT><A HREF="#_Toc415978394">*</A></P>
<FONT FACE="Times"><P>2) Requirements Specification&#9;</FONT><A HREF="#_Toc415978395">*</A></P>
<FONT FACE="Times"><P>3) CDIF Transfer Format&#9;</FONT><A HREF="#_Toc415978396">*</A></P>
<FONT FACE="Times"><P>4) The Data Model&#9;</FONT><A HREF="#_Toc415978397">*</A></P>
<FONT FACE="Times"><P>4.1. The Core Model&#9;</FONT><A HREF="#_Toc415978398">*</A></P>
<FONT FACE="Times"><P>4.2. Level of Reification&#9;</FONT><A HREF="#_Toc415978399">*</A></P>
<FONT FACE="Times"><P>4.3. Entity / Association (the Meta-Meta Model)&#9;</FONT><A HREF="#_Toc415978400">*</A></P>
<FONT FACE="Times"><P>4.4. Basic Data Types&#9;</FONT><A HREF="#_Toc415978401">*</A></P>
<FONT FACE="Times"><P>4.5. Core Entity: ClassDefinition&#9;</FONT><A HREF="#_Toc415978402">*</A></P>
<FONT FACE="Times"><P>4.6. Core Entity: MethodDefinition&#9;</FONT><A HREF="#_Toc415978403">*</A></P>
<FONT FACE="Times"><P>4.7. Core Entity: AttributeDefinition&#9;</FONT><A HREF="#_Toc415978404">*</A></P>
<FONT FACE="Times"><P>4.8. Core Association: InheritanceDefinition&#9;</FONT><A HREF="#_Toc415978405">*</A></P>
<FONT FACE="Times"><P>4.9. Core Association: VariableAccess&#9;</FONT><A HREF="#_Toc415978406">*</A></P>
<FONT FACE="Times"><P>4.10. Core Association: MethodInvocation&#9;</FONT><A HREF="#_Toc415978407">*</A></P>
<FONT FACE="Times"><P>4.11. ArgumentDescriptor&#9;</FONT><A HREF="#_Toc415978408">*</A></P>
<FONT FACE="Times"><P>4.12. VariableDefinition&#9;</FONT><A HREF="#_Toc415978409">*</A></P>
<FONT FACE="Times"><P>4.13. VariableDefinition&#9;</FONT><A HREF="#_Toc415978410">*</A></P>
<FONT FACE="Times"><P>4.14. GlobalVariableDefinition&#9;</FONT><A HREF="#_Toc415978411">*</A></P>
<FONT FACE="Times"><P>4.15. ImplicitVariableDefinition&#9;</FONT><A HREF="#_Toc415978412">*</A></P>
<FONT FACE="Times"><P>4.16. LocalVariableDefinition&#9;</FONT><A HREF="#_Toc415978413">*</A></P>
<FONT FACE="Times"><P>4.17. FormalParameterDefinition&#9;</FONT><A HREF="#_Toc415978414">*</A></P>
<FONT FACE="Times"><P>5) Open Questions&#9;</FONT><A HREF="#_Toc415978415">*</A></P>
<FONT FACE="Times"><P>5.1. Why not UML?&#9;</FONT><A HREF="#_Toc415978416">*</A></P>
<FONT FACE="Times"><P>5.2. Why not CORBA/IDL?&#9;</FONT><A HREF="#_Toc415978417">*</A></P>
<FONT FACE="Times"><P>5.3. What about Dynamic Information?&#9;</FONT><A HREF="#_Toc415978418">*</A></P>
<FONT FACE="Times"><P>5.4. How do you handle hybrid languages (C++, Ada...)?&#9;</FONT><A HREF="#_Toc415978419">*</A></P>
<FONT FACE="Times"><P>6) References&#9;</FONT><A HREF="#_Toc415978420">*</A></P>
<FONT FACE="Times"><P>6.1. FAMOOS Internal References&#9;</FONT><A HREF="#_Toc415978421">*</A></P>
<FONT FACE="Times"><P>6.2. External References&#9;</FONT><A HREF="#_Toc415978422">*</A></P></DIR>

<B><FONT FACE="Times"><P>Cover Pages&#9;</B></FONT><A HREF="#_Toc415978423">*</A></P><DIR>

<FONT FACE="Times"><P>1.&#9;IDENTIFICATION&#9;</FONT><A HREF="#_Toc415978424">*</A></P>
<FONT FACE="Times"><P>2.&#9;ABSTRACT&#9;</FONT><A HREF="">*</A></P>
<FONT FACE="Times"><P>3.&#9;KEYWORDS&#9;</FONT><A HREF="">*</A></P>
<FONT FACE="Times"><P>4.&#9;VERSION HISTORY&#9;</FONT><A HREF="">*</A></P>
<FONT FACE="Times"><P>5.&#9;TABLE OF CONTENTS&#9;</FONT><A HREF="#_Toc415978428">*</A></P>
<FONT FACE="Times"><P>6.&#9;LIST OF FIGURES&#9;</FONT><A HREF="">*</A></P>
<FONT FACE="Times"><P>7.&#9;LIST OF TABLES&#9;</FONT><A HREF="#_Toc415978430">*</A></P>
<P>&nbsp;</P></DIR>
</DIR>
</P>
<H2>8) List of Figures</H2>
<FONT FACE="Times"><P>Figure 1: FAMOOS re-engineering life cycle&#9;</FONT><A HREF="#_Toc415978431">*</A><DIR>
<DIR>

<FONT FACE="Times"><P>Figure 2: Conception of the Common Exchange Format&#9;</FONT><A HREF="#_Toc415978432">*</A></P>
<FONT FACE="Times"><P>Figure 3: The Core Model&#9;</FONT><A HREF="#_Toc415978433">*</A></P>
<FONT FACE="Times"><P>Figure 4: The Meta-Meta Model (Entity, Association)&#9;</FONT><A HREF="#_Toc415978434">*</A></P>
<FONT FACE="Times"><P>Figure 5: Basic Data Types (Name, Qualifier and Index)&#9;</FONT><A HREF="#_Toc415978435">*</A></P>
<FONT FACE="Times"><P>Figure 6: ClassDefinition&#9;</FONT><A HREF="#_Toc415978436">*</A></P>
<FONT FACE="Times"><P>Figure 7: MethodDefinition&#9;</FONT><A HREF="#_Toc415978437">*</A></P>
<FONT FACE="Times"><P>Figure 8: AttributeDefinition&#9;</FONT><A HREF="#_Toc415978438">*</A></P>
<FONT FACE="Times"><P>Figure 9: InheritanceDefinition&#9;</FONT><A HREF="#_Toc415978439">*</A></P>
<FONT FACE="Times"><P>Figure 10: VariableAccess&#9;</FONT><A HREF="#_Toc415978440">*</A></P>
<FONT FACE="Times"><P>Figure 11: MethodInvocation&#9;</FONT><A HREF="#_Toc415978441">*</A></P>
<FONT FACE="Times"><P>Figure 12: ArgumentDescriptor, ComplexExpression &amp; SimpleVariableAccess&#9;</FONT><A HREF="#_Toc415978442">*</A></P>
<FONT FACE="Times"><P>Figure 13: VariableDefinition Hierarchy&#9;</FONT><A HREF="#_Toc415978443">*</A></P>
<FONT FACE="Times"><P>Figure 14: VariableDefinition&#9;</FONT><A HREF="#_Toc415978444">*</A></P>
<FONT FACE="Times"><P>Figure 15: GlobalVariableDefinition&#9;</FONT><A HREF="#_Toc415978445">*</A></P>
<FONT FACE="Times"><P>Figure 16: ImplicitVariableDefinition&#9;</FONT><A HREF="#_Toc415978446">*</A></P>
<FONT FACE="Times"><P>Figure 17: LocalVariableDefinition&#9;</FONT><A HREF="#_Toc415978447">*</A></P>
<FONT FACE="Times"><P>Figure 18: FormalParameterDefinition&#9;</FONT><A HREF="#_Toc415978448">*</A></P>
<P>&nbsp;</P></DIR>
</DIR>
 <A NAME="_Toc415978430"></P>
<H2>9) </A>List of Tables</H2>
<FONT FACE="Times"><P>Table 1: Levels of Reification&#9;</FONT><A HREF="#_Toc415978449">*</A>
<P>&nbsp;</P></P></BODY>
</HTML>
